package rightaway3d.house.view3d.base
{
	import flash.geom.Point;
	
	import away3d.core.base.CompactSubGeometry;
	import away3d.primitives.PrimitiveBase;
	
	import rightaway3d.house.utils.Geom;
	import rightaway3d.house.utils.Point3D;
	import rightaway3d.house.utils.Triangle;
	import rightaway3d.house.utils.Vertex;
	import rightaway3d.house.vo.CrossWall;
	import rightaway3d.house.vo.Room;
	

	public class CeilingGeometry extends PrimitiveBase
	{
		public function CeilingGeometry(room:Room)
		{
			super();
			this.vo = room;
			groundGeom = this.subGeometries[0] as CompactSubGeometry;
			//ceilingGeom = getSubGeom();
		}
		
		private var vo:Room;
		
		private var numVertices:int;
		private var numIndices:int;
		
		private var vertexIndex:int;
		
		private var strideSkip:int;
		private var stride:uint;
		
		private var groundGeom:CompactSubGeometry;
		private var ceilingGeom:CompactSubGeometry;
		
		/**
		 * 墙体正面贴图材质的宽度，用于计算贴图UV
		 */
		public var groundTextureWidth:Number = 500;
		/**
		 * 墙体正面贴图材质的高度，用于计算贴图UV
		 */
		public var groundTextureHeight:Number = 500;
		
		/**
		 * 墙体背面贴图材质的宽度，用于计算贴图UV
		 */
		public var ceilingTextureWidth:Number = 500;
		/**
		 * 墙体背面贴图材质的高度，用于计算贴图UV
		 */
		public var ceilingTextureHeight:Number =  500;
		
		private function getSubGeom():CompactSubGeometry
		{
			var subGeom:CompactSubGeometry = new CompactSubGeometry();
			subGeom.autoGenerateDummyUVs = false;
			addSubGeometry(subGeom);
			return subGeom;
		}
		
		public function updateGeometry():void
		{
			this.invalidateGeometry();
			//this.subGeometries[0]
		}
		
		public function updateUVs():void
		{
			this.invalidateUVs();
		}
		
		/**
		 * @inheritDoc
		 */
		protected override function buildGeometry(target:CompactSubGeometry):void
		{
			_buildGeom(target,countNumVertices,createFace);
		}
		
		private function _buildGeom(target:CompactSubGeometry,countVerticesFun:Function,createFaceFun:Function):void
		{
			var data:Vector.<Number>;//顶点数据集
			var indices:Vector.<uint>;//顶点索引集
			
			vertexIndex = target.vertexOffset;
			stride = target.vertexStride;
			strideSkip = stride - 9;
			
			//countNumVertices();
			var vs:Vector.<Vertex> = new Vector.<Vertex>();
			var ts:Vector.<Triangle> = new Vector.<Triangle>();
			countVerticesFun(vs,ts);
			
			if (numVertices == target.numVertices) {
				data = target.vertexData;
				indices = target.indexData || new Vector.<uint>(numIndices, true);
			} else {
				data = new Vector.<Number>(numVertices*stride, true);
				indices = new Vector.<uint>(numIndices, true);
				invalidateUVs();
			}
			
			numIndices = 0;
			
			createFaceFun(data,indices,target,vs,ts);
			
			target.updateData(data);
			target.updateIndexData(indices);
			
			target.scaleUV(3,3);
		}
		
		private function countNumVertices(vs:Vector.<Vertex>,ts:Vector.<Triangle>):void
		{
			var cws:Vector.<CrossWall> = vo.walls;
			var len:int = cws.length;
			numVertices = len;
			
			for(var i:int=0;i<len;i++)
			{
				var v:Vertex = new Vertex();
				v.index = i;
				v.point = getDrawPoint(cws[i]);
				vs.push(v);
			}
			
			Geom.splitPolygonByTriangle(vs.concat(),ts);
			numIndices = ts.length * 3;
		}
		
		private function createFace(data:Vector.<Number>,indices:Vector.<uint>,target:CompactSubGeometry,vs:Vector.<Vertex>,ts:Vector.<Triangle>):void
		{
			var len:int = numVertices;
			var minX:Number=Infinity,minY:Number=Infinity,maxX:Number=-Infinity,maxY:Number=-Infinity;
			for(i=0;i<len;i++)
			{
				p = vs[i].point;
				if(minX>p.x)minX=p.x;
				if(minY>p.y)minY=p.y;
				if(maxX<p.x)maxX=p.x;
				if(maxY<p.y)maxY=p.y;
			}
			
			var dx:Number = maxX - minX;
			var dy:Number = maxY - minY;
			
			var su:Number = dx/groundTextureWidth;
			var sv:Number = dy/groundTextureHeight;
			
			var nx:Number=0,ny:Number=1,nz:Number=0,tx:Number=1,ty:Number=0,tz:Number=0;
			var y:Number = 0;
			var u:Number,v:Number;
			
			for(var i:int=0;i<len;i++)
			{
				var p:Point = vs[i].point;
				u = (p.x - minX)/dx * su;
				v = (1-(p.y - minY)/dy) * sv;
				addVertexUV(data,p.x,y,p.y,nx,ny,nz,tx,ty,tz,u,v);
			}
			
			len = ts.length;
			for(i=0;i<len;i++)
			{
				var t:Triangle = ts[i];
				indices[numIndices++] = t.p0.index;
				indices[numIndices++] = t.p1.index;
				indices[numIndices++] = t.p2.index;
			}
		}
		
		private function addVertex(data:Vector.<Number>,x:Number,y:Number,z:Number,nx:Number,ny:Number,nz:Number,tx:Number,ty:Number,tz:Number):void
		{
			_addVertex(data,x,y,z,nx,ny,nz,tx,ty,tz);			
			vertexIndex += strideSkip;
		}
		
		private function addVertexUV(data:Vector.<Number>,x:Number,y:Number,z:Number,nx:Number,ny:Number,nz:Number,tx:Number,ty:Number,tz:Number,u:Number,v:Number):void
		{
			//trace("addVertexUV:"+u,v);
			_addVertex(data,x,y,z,nx,ny,nz,tx,ty,tz);			
			data[vertexIndex++] = u;
			data[vertexIndex++] = v;
			data[vertexIndex++] = u;
			data[vertexIndex++] = v;
		}
		
		private function _addVertex(data:Vector.<Number>,x:Number,y:Number,z:Number,nx:Number,ny:Number,nz:Number,tx:Number,ty:Number,tz:Number):void
		{
			//trace("addVertex vertexIndex:"+(getCurrVertexIndex()),vertexIndex+" xyz:"+x,y,z);
			data[vertexIndex++] = x;
			data[vertexIndex++] = y;
			data[vertexIndex++] = z;
			
			data[vertexIndex++] = nx;
			data[vertexIndex++] = ny;
			data[vertexIndex++] = nz;
			
			data[vertexIndex++] = tx;
			data[vertexIndex++] = ty;
			data[vertexIndex++] = tz;
		}
		
		private function getDrawPoint(cw:CrossWall,p:Point=null):Point
		{
			var p0:Point3D = cw.isHead ? cw.wall.groundFrontHeadPoint : cw.wall.groundBackEndPoint;
			
			p ||= new Point();
			p.x = p0.x;
			p.y = p0.z;
			
			return p;
		}
		
		/**
		 * @inheritDoc
		 */
		override protected function buildUVs(target:CompactSubGeometry):void
		{
		}
	}
}




