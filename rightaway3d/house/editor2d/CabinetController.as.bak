package rightaway3d.house.editor2d
{
	import flash.display.Stage;
	import flash.events.Event;
	import flash.events.MouseEvent;
	import flash.geom.Point;
	import flash.geom.Vector3D;
	import flash.utils.Dictionary;
	
	import away3d.core.pick.PickingColliderType;
	import away3d.events.MouseEvent3D;
	
	import rightaway3d.engine.core.EngineManager;
	import rightaway3d.engine.product.ProductInfo;
	import rightaway3d.engine.product.ProductManager;
	import rightaway3d.engine.product.ProductObject;
	import rightaway3d.engine.utils.GlobalEvent;
	import rightaway3d.house.cabinet.Cabinet2D;
	import rightaway3d.house.cabinet.CircularColumn2D;
	import rightaway3d.house.cabinet.SquarePillar2D;
	import rightaway3d.house.utils.Geom;
	import rightaway3d.house.utils.Point3D;
	import rightaway3d.house.utils.TestNumer;
	import rightaway3d.house.view2d.Base2D;
	import rightaway3d.house.view2d.Product2D;
	import rightaway3d.house.view2d.Room2D;
	import rightaway3d.house.view2d.Wall2D;
	import rightaway3d.house.vo.CrossWall;
	import rightaway3d.house.vo.House;
	import rightaway3d.house.vo.Room;
	import rightaway3d.house.vo.Wall;
	import rightaway3d.house.vo.WallHole;
	import rightaway3d.house.vo.WallObject;
	
	import ztc.meshbuilder.room.CabinetTable3D;
	import ztc.meshbuilder.room.CabinetTableTool;

	public class CabinetController
	{
		public var scene:Scene2D;
		public var sceneController:SceneController2D;
		public var engineManager:EngineManager;
		
		private var productManager:ProductManager = ProductManager.own;
		
		private var stage:Stage;
		
		public var currCabinet:Product2D;
		
		private var _cabinetTableDefaultMaterial:String;

		public function get cabinetTableDefaultMaterial():String
		{
			return _cabinetTableDefaultMaterial;
		}

		//设置默认材质时，要重新设置当前已经创建的台面
		public function set cabinetTableDefaultMaterial(value:String):void
		{
			_cabinetTableDefaultMaterial = value;
			for each(var ct:CabinetTable3D in tableMeshs)
			{
				ct.setMaterial(value);
			}
		}

		private var _cabinetBodyDefaultMaterial:String;

		public function get cabinetBodyDefaultMaterial():String
		{
			return _cabinetBodyDefaultMaterial;
		}
		
		//设置默认材质时，要重新设置当前已经创建的柜体
		public function set cabinetBodyDefaultMaterial(value:String):void
		{
			_cabinetBodyDefaultMaterial = value;
			ProductInfo.customMaterialDict["cabinet_body_plank"] = value;
			productManager.setProductMaterial("cabinet_body_plank",value);
		}

		
		private var _cabinetDoorDefaultMaterial:String;

		public function get cabinetDoorDefaultMaterial():String
		{
			return _cabinetDoorDefaultMaterial;
		}
		
		//设置默认材质时，要重新设置当前已经创建的柜门
		public function set cabinetDoorDefaultMaterial(value:String):void
		{
			_cabinetDoorDefaultMaterial = value;
			ProductInfo.customMaterialDict["cabinet_door_plank"] = value;
			productManager.setProductMaterial("cabinet_door_plank",value);
		}
		
		/**
		 * 设置厨柜门的材质
		 * @param cabinet
		 * @param matName
		 * @param isGroup
		 * 
		 */
		public function setCabinetDoorMaterial(cabinet:ProductObject,matName:String,isGroup:Boolean):void
		{
			if(isGroup)
			{
				cabinet.customMaterialName = matName;
			}
			else
			{
				productManager.setProductMaterial("cabinet_door_plank",matName,cabinet.position.y);
			}
		}

		
		private var rooms:Vector.<Room2D>;
		
		private var products:Array = [];
		
		public function deleteCurrProduct():void
		{
			if(!currCabinet)return;
			
			if(currCabinet==_drainer)_drainer = null;
			else if(currCabinet==_flue)_flue = null;
			
			products.splice(products.indexOf(currCabinet),1);
			
			deleteProduct(currCabinet);
			
			currCabinet = null;
			
			scene.render();
		}
		
		public function deleteAllProduct():void
		{
			removeTableMeshs();
			
			for each(var p:Product2D in products)
			{
				deleteProduct(p);
			}
			
			products.length = 0;
			currCabinet = null;
			
			_drainer = null;
			_flue = null;
			
			scene.render();
		}
		
		private function deleteProduct(p:Product2D):void
		{
			p.vo.dispose();
		}
		
		/**
		 * 障碍物集合
		 */
		private var obstacleDict:Dictionary = new Dictionary();
		
		private function addProduct(p:Product2D):void
		{
			p.vo.addEventListener("will_dispose",onDisposeProduct);
			p.addEventListener(MouseEvent.MOUSE_DOWN,onSelectProduct);
			products.push(p);
		}
		
		private function onDisposeProduct(e:Event):void
		{
			var po:ProductObject = e.currentTarget as ProductObject;
			po.removeEventListener("will_dispose",onDisposeProduct);
			
			engineManager.removeRootChild(po.container3d);
			engineManager.removeCollisionObject(po.container3d);
			
			var p:Product2D = po.view2d;
			p.removeEventListener(MouseEvent.MOUSE_DOWN,onSelectProduct);

			removeProduct(p);
			p.dispose();
			
			if(obstacleDict[po])
			{
				delete obstacleDict[po];
			}
			
			if(cabinetDict[po])
			{
				delete cabinetDict[po];
			}
		}
		
		public function createProduct(vo:ProductObject):void
		{
			var p:Product2D = new Product2D(vo);
			addProduct(p);
			
			var wo:WallObject = vo.objectInfo;
			
			vo.productInfo.dimensions.x = wo.width;
			vo.productInfo.dimensions.y = wo.height;
			vo.productInfo.dimensions.z = wo.depth;
			
			p.border = 0x999999;
			
			var yPos:int = wo.y+wo.height;
			if(yPos>720)
			{
				scene.addProduct(p,2);
				p.fill = 0xccccaa;
			}
			else if(yPos>=80)
			{
				scene.addProduct(p,1);
				p.fill = 0xccccbb;
			}
			else
			{
				scene.addProduct(p,0);
				if(vo.modelObject)
				{
					p.fill = vo.modelObject.modelInfo.color;
				}
			}
			
			sceneHeightSize = Scene2D.sceneHeightSize;
			
			setCabinetPos(p,wo.crossWall,wo.x,wo.y,wo.z);
			
			p.updateView();
		}
		
		//==========================================================================
		/**
		 * 是否锁定厨柜及水盆烟机灶台电器
		 * @param value
		 */
		public function lockCabinetObject(value:Boolean):void
		{
			for(var po:ProductObject in cabinetDict)
			{
				po.isLock = value;
			}
		}
		
		/**
		 * 清除所有厨柜及水盆烟机灶台电器
		 */
		public function clearAllCabinetObject():void
		{
			for(var vo:ProductObject in cabinetDict)
			{
				vo.dispose();
				
				products.splice(products.indexOf(vo.view2d),1);
			}
		}
		
		private var cabinetDict:Dictionary = new Dictionary();
		
		public function createCabinet(infoID:int,fileURL:String,dataFormat:String="text",cw:CrossWall=null,xPos:int=-1,yPos:uint=0,name:String="",isDrag:Boolean=true,width:int=100,depth:int=100):void
		{
			//trace("----createCabinet");
			var p:Product2D = new Cabinet2D(infoID,fileURL,dataFormat);
			//trace("width:"+width);
			p.vo.objectInfo.width = width;
			p.vo.objectInfo.depth = depth;
			
			addProduct(p);
			setCurrProduct(p);
			
			cabinetDict[p.vo] = p;
			
			if(name)p.vo.name = name;
			
			if(!cw && isDrag)
			{
				initEvent();
			}
			
			if(yPos>720)
			{
				if(cw)scene.addProduct(p,2);
				p.border = 0x999999;
				p.fill = 0xccccaa;
				//var zPos:Number = 0;
			}
			else
			{
				if(cw)scene.addProduct(p,1);
				p.border = 0x999999;
				p.fill = 0xccccbb;
				//zPos = WallObject.distToWall;
			}
			
			initCabinet(cw,xPos,yPos,0);
			//initCabinet(cw,xPos,yPos,-1);
		}
		
		private var _drainer:Product2D;//水盆柜标志
		private var _flue:Product2D;//灶台柜标志
		
		/**
		 * 是否已经指定的灶台位置
		 * @return 
		 * 
		 */
		public function hasHearth ():Boolean
		{
			return Boolean(_flue && _flue.wall);
		}
		
		/**
		 * 是否已经指定了水盆位置
		 * @return 
		 * 
		 */
		public function hasBasin():Boolean
		{
			return Boolean(_drainer && _drainer.wall);
		}
		
		/**
		 * 创建横向管道
		 * @param diameter：直径，单位mm
		 * @param length：管长度，单位mm
		 * @param color：颜色
		 * @param yPos：管下沿至地面高度
		 * @param zPos：管吸附到墙体时，与墙体的间距
		 */
		public function createHorizontalTube(diameter:uint,length:uint,color:uint,yPos:uint,zPos:uint):void
		{
			var p:Product2D = createCircularColumn("HorizontalTube",diameter,length,color,yPos,zPos,new Vector3D(0,0,90));
		}
		
		/**
		 * 创建与房间齐高的圆管（圆柱）
		 * @param diameter：直径，单位mm
		 * @param color：颜色
		 * @param zPos：管吸附到墙体时，与墙体的间距
		 */
		public function createRoomCircularColumn(diameter:uint,color:uint,zPos:uint=0):void
		{
			var pName:String = "RoomCircularColumn";
			var height:int = scene.currFloor.vo.ceilingHeight;
			var yPos:uint = 0;
			var p:Product2D = createCircularColumn(pName,diameter,height,color,yPos,zPos);
		}
		
		/**
		 * 创建竖管道
		 * @param pName：名称
		 * @param diameter：直径，单位mm
		 * @param height：管高度，单位mm
		 * @param color：颜色
		 * @param yPos：管底至地面高度
		 * @param zPos：管吸附到墙体时，与墙体的间距
		 * @param rotation：旋转管子
		 * @return 管子产品的二维视图
		 */
		public function createCircularColumn(pName:String,diameter:uint,height:uint,color:uint,yPos:uint,zPos:uint,rotation:Vector3D=null):Product2D
		{
			var fh:int = scene.currFloor.vo.ceilingHeight;
			if(height>fh)height = fh;
			if(yPos+height>fh)yPos = fh - height;
			
			var p:Product2D = new CircularColumn2D(pName,diameter,height,color,false,rotation);
			p.vo.objectInfo.isIgnoreObject = true;
			
			obstacleDict[p.vo] = p;
			
			addProduct(p);
			setCurrProduct(p);
			
			initEvent();
			
			initCabinet(null,-1,yPos,zPos);
			
			return p;
		}
		
		/**
		 * 创建水盆定位标志
		 */
		public function createDrainerFlag():void
		{
			if(_drainer)return;
			
			var p:Product2D = createSquareObject("drainer",700,50,300,0x8080ff,0,100);
			p.loadImage("assets/image/icon_shuipen.png");
			p.errorFlag = true;
			
			_drainer = p;
			p.vo.container3d.visible = false;
		}
		
		/**
		 * 创建灶台定位标志
		 */
		public function createFlueFlag():void
		{
			if(_flue)return;
			
			var p:Product2D = createSquareObject("flue",700,50,300,0xff8080,0,100);
			p.loadImage("assets/image/icon_zaotai.png");
			p.errorFlag = true;
			
			_flue = p;
			p.vo.container3d.visible = false;
		}
		
		/**
		 * 是否锁定定位标志
		 * @param value
		 */
		public function lockLocationFlag(value:Boolean):void
		{
			if(_flue)_flue.visible = !value;
			if(_drainer)_drainer.visible = !value;
		}
		
		/**
		 * 清除定位标志
		 */
		public function clearLocationFlag():void
		{
			if(_flue)
			{
				_flue.vo.dispose();
				
				products.splice(products.indexOf(_flue),1);
				_flue = null;
			}
			
			if(_drainer)
			{
				_drainer.vo.dispose();
				
				products.splice(products.indexOf(_drainer),1);
				_drainer = null;
			}
		}
		
		/**
		 * 创建与房间齐高的方柱（烟道）
		 * @param width：柱子宽度，单位mm
		 * @param depth：柱子进深，单位mm
		 * @param color：颜色
		 * @param zPos：柱子吸附到墙体时，与墙体的间距
		 */
		public function createRoomSquarePillar(width:uint,depth:uint,color:uint,zPos:uint=0):void
		{
			var pName:String = "RoomSquarePillar";
			var height:int = scene.currFloor.vo.ceilingHeight;
			var yPos:uint = 0;
			var p:Product2D = createSquareObject(pName,width,height,depth,color,yPos,zPos);
			p.vo.objectInfo.isIgnoreObject = false;
		}
		
		/**
		 * 创建方形物体
		 * @param pName：名称
		 * @param width：物体宽度，单位mm
		 * @param height：物体高度，单位mm
		 * @param depth：物体进深，单位mm
		 * @param color：颜色
		 * @param yPos：物体底面至地面高度
		 * @param zPos：物体吸附到墙体时，与墙体的间距
		 * @return 物体的二维视图
		 */
		public function createSquareObject(pName:String,width:int,height:int,depth:int,color:uint,yPos:uint,zPos:uint):Product2D
		{
			var fh:int = scene.currFloor.vo.ceilingHeight;
			if(height>fh)height = fh;
			if(yPos+height>fh)yPos = fh - height;
			
			var p:Product2D = new SquarePillar2D(pName,width,height,depth,color,false);
			p.vo.objectInfo.isIgnoreObject = true;
			
			obstacleDict[p.vo] = p;
			
			addProduct(p);
			setCurrProduct(p);
			
			initEvent();
			
			initCabinet(null,-1,yPos,zPos);
			
			return p;
			
		}
		
		/**
		 * 清除所有障碍物
		 */
		public function clearAllObstacle():void
		{
			for(var vo:ProductObject in obstacleDict)
			{
				vo.dispose();
				
				products.splice(products.indexOf(vo.view2d),1);
			}
		}
		
		/**
		 * 是否锁定所有障碍物，锁定后将不能编辑障碍物
		 * @param value
		 */
		public function lockObstacle(value:Boolean):void
		{
			for(var vo:ProductObject in obstacleDict)
			{
				vo.isLock = value;
			}
			
			if(value && this.currCabinet)
			{
				this.currCabinet.selected = false;
				this.currCabinet.updateView();
				this.currCabinet = null;
			}
		}
		
		/**
		 * 设置物体位置
		 * @param po：物体对象
		 * @param xPos：在墙面上新位置
		 * @param yPos：物体的新高度
		 * @param zPos：离墙的距离
		 */
		public function setObjectPosition(po:ProductObject,xPos:int,yPos:int,zPos:Number):void
		{
			var cw:CrossWall = po.objectInfo.crossWall;
			if(!cw)return;
			
			xPos += cw.localHead.x + po.productInfo.dimensions.x;
			
			var x0:Number = cw.localHead.x;//wall.groundFrontHead.x;
			var x1:Number = cw.localEnd.x;//wall.groundFrontEnd.x;
			var o:WallObject = po.objectInfo;
			var tx:Number = o.x;
			o.x = xPos;
			if(cw.testObject(x0,x1,o))
			{
				xPos = o.x;
				this.setCabinetPos(po.view2d,cw,xPos,yPos,zPos);
			}
			else
			{
				o.x = tx;
			}
		}
		
		private function removeProduct(p:Product2D):void
		{
			if(p.parent==scene)
			{
				scene.removeChild(p);
			}
			else
			{
				var obj:WallObject = p.vo.objectInfo;
				var h:int = obj.y + obj.height;
				//trace("-----"+h,obj.y,obj.height);
				
				var level:int = h < 80 ? 0 : (h < 1540 ? 1 : 2);
				scene.removeProduct(p,level);
			}
		}
		
		private var isMove:Boolean;
		private function onSelectProduct(event:MouseEvent):void
		{
			var p:Product2D = event.currentTarget as Product2D;
			
			if(p.vo.isLock)return;//锁定时，不准操作
			
			setCurrProduct(p);
			
			var wo:WallObject = p.vo.objectInfo;
			currCrossWall = wo.crossWall;
			
			if(currCrossWall)
			{
				currCrossWall.removeWallObject(p.vo.objectInfo);
				currCrossWall.initTestObject();
			}
			
			removeProduct(p);

			this.scene.enable = false;
			p.enable = false;
			
			isMove = false;
			
			stage = scene.stage;
			stage.addEventListener(MouseEvent.MOUSE_MOVE,movingCabinet);
			stage.addEventListener(MouseEvent.MOUSE_UP,endMoveCabinet);
			
			initCabinet(currCrossWall,wo.x,wo.y,wo.z,false);
			
			scene.render();
			
			GlobalEvent.event.dispatchProductMouseDownEvent(p.vo);
		}
		
		private function initEvent():void
		{
			this.scene.enable = false;
			currCabinet.enable = false;
			
			stage = scene.stage;
			stage.addEventListener(MouseEvent.MOUSE_MOVE,movingCabinet);
			stage.addEventListener(MouseEvent.CLICK,endMoveCabinet);
		}
		
		private function initCabinet(cw:CrossWall=null,xPos:int=-1,yPos:uint=0,zPos:uint=0,setPos:Boolean=true):void
		{
			//trace("initCabinet");
			sceneHeightSize = Scene2D.sceneHeightSize;
			
			rooms = scene.currFloor.rooms;
			
			if(!currCabinet.stage)scene.addChild(currCabinet);
			
			currCabinet.vo.objectInfo.x = xPos;
			currCabinet.vo.objectInfo.y = yPos;
			currCabinet.vo.objectInfo.z = zPos;
			
			//currCabinet.vo.position.y = yPos;
			
			if(!cw)
			{
				//trace("initCabinet1");
				stage = scene.stage;
				mousePoint.x = stage.mouseX;
				mousePoint.y = stage.mouseY;
				
				var localPoint:Point = scene.globalToLocal(mousePoint);
				
				currCabinet.x = localPoint.x - currCabinet.width * 0.5;
				currCabinet.y = localPoint.y + currCabinet.height * 0.5;
				
				mousePoint.x = Base2D.screenToSize(localPoint.x);
				mousePoint.y = sceneHeightSize - Base2D.screenToSize(localPoint.y);
				
				var pObj:ProductObject = currCabinet.vo;
				pObj.position.x = mousePoint.x - pObj.productInfo.dimensions.x * 0.5;
				pObj.position.z = mousePoint.y + pObj.productInfo.dimensions.z * 0.5;
				
				currCabinet.vo.position.y = currCabinet.vo.container3d.y = yPos;
			}
			else if(setPos)
			{
				setCabinetPos(currCabinet,cw,xPos,yPos,zPos);
			}
			
			//trace("1");
			currCabinet.updateView();
		}
		
		private function setCurrProduct(p:Product2D):void
		{
			if(currCabinet == p)return;
			
			//trace("setCurrProduct:"+p.selected);
			if(currCabinet)
			{
				//trace("currCabinet:"+currCabinet.selected);
				currCabinet.selected = false;
				currCabinet.updateView();
			}
			
			p.selected = true;
			currCabinet = p;
		}
		
		private function setCabinetPos(cabinet:Product2D,cw:CrossWall,xPos:int,yPos:int,zPos:Number):void
		{
			//trace("setCabinetPos:",xPos,yPos,zPos);
			if(cw)
			{
				//if(zPos<0)zPos = WallObject.distToWall;
				zPos += cw.wall.width*0.5;
				
				footPoint.x = xPos;
				footPoint.y = cw.isHead?-zPos:zPos;
				//trace("footPoint1:"+footPoint);
				cw.wall.localToGlobal2(footPoint,footPoint);
				//trace("footPoint2:"+footPoint);
				
				cabinet.vo.position.x = footPoint.x;
				cabinet.vo.position.z = footPoint.y;
				
				var a:Number = 360 - cw.wall.angles;
				cabinet.rotation = cw.isHead ? a+180 : a;
				
				cabinet.vo.rotation.y = cabinet.vo.container3d.rotationY = cabinet.rotation;
				
				if(!cabinet.vo.objectInfo.crossWall)
				{
					cw.addWallObject(cabinet.vo.objectInfo);
				}
			}
			else
			{
				footPoint.x = cabinet.vo.position.x;
				footPoint.y = cabinet.vo.position.z;
			}
			
			cabinet.vo.position.y = cabinet.vo.container3d.y = yPos;
			
			cabinet.x = Base2D.sizeToScreen(footPoint.x);
			cabinet.y = Base2D.sizeToScreen(sceneHeightSize - footPoint.y);
			//trace("footPoint3:"+cabinet.x,cabinet.y);
		}
		
		private function getWall2d(room2d:Room2D,cw:CrossWall):Wall2D
		{
			var walls:Dictionary = room2d.walls;
			for(var w:Wall2D in walls)
			{
				if(walls[w]==cw)
				{
					return w;
				}
			}
			return null;
		}
		
		//private var tmpPoint:Point = new Point();
		private var sceneHeightSize:int;
		
		private var footPoint:Point = new Point();
		
		private var mousePoint:Point = new Point();
		
		private var currCrossWall:CrossWall;
		
		private var currRoom2d:Room2D;
		
		private function movingCabinet(event:MouseEvent):void
		{
			//trace("movingCabinet");
			isMove = true;

			var mouseX0:Number = stage.mouseX;
			var mouseY0:Number = stage.mouseY;
			
			mousePoint.x = mouseX0;
			mousePoint.y = mouseY0;
			var localPoint:Point = scene.globalToLocal(mousePoint);
			//trace("mousePoint1:"+mousePoint);
			
			mousePoint.x = Base2D.screenToSize(localPoint.x);
			mousePoint.y = sceneHeightSize - Base2D.screenToSize(localPoint.y);
			//trace("mousePoint2:"+mousePoint);
			var inRoom:Boolean = false;
			if(!currCrossWall)//当前产品未吸附在墙上
			{
				for each(var room2d:Room2D in rooms)
				{
					var room:Room = room2d.vo;
					inRoom = room.hitTestPoint(mousePoint.x,mousePoint.y);
					//trace("inRoom:"+inRoom);
					if(inRoom)
					{
						currCrossWall = room.getNearestWall(mousePoint,footPoint);
						currCrossWall.initTestObject();
						currRoom2d = room2d;
						break;
					}
				}
				
				if(currCabinet==_drainer || currCabinet==_flue)//将关联到水盆或灶台的墙体视图置为选择状态
				{
					if(inRoom)
					{
						var w:Wall2D = getWall2d(currRoom2d,currCrossWall);
						if(w)
						{
							w.selected = true;
							currCabinet.wall = w;
						}
					}
				}
			}
			
			if(currCrossWall)//当前产品被吸附在某个墙上
			{
				var cw:CrossWall = currCrossWall;
				var wall:Wall = cw.wall;
				var ww:Number = wall.width * 0.5;
				var bounds:Vector3D = currCabinet.vo.productInfo.dimensions;
				var dist:Number = wall.distToPoint(mousePoint,footPoint);//计算当前点到墙体的垂直距离，及当前垂足坐标
				if(dist<800)
				{
					wall.globalToLocal2(footPoint,footPoint);
					//trace("footPoint1:"+footPoint);
					var dx:Number = bounds.x * 0.5;
					footPoint.x += cw.isHead?dx:-dx;
					var zWall:int = currCabinet.vo.objectInfo.z;
					var dy:Number = zWall + ww;
					
					/*if(zWall>-1)
					{
						var dy:Number = zWall + ww;
					}
					else
					{
						var hz:Number = bounds.z * 0.5;
						dist -= hz;
						if(dist<ww)
						{
							dy = ww;
						}
						else if(dist>ww+WallObject.distToWall+570-bounds.z)
						{
							dy = ww+WallObject.distToWall+570-bounds.z;
						}
						else
						{
							dy = dist;
						}
					}*/
					
					footPoint.y = cw.isHead?-dy:dy;
					
					currCabinet.vo.objectInfo.x = footPoint.x;
					
					var result:Boolean = cw.testAddObject(currCabinet.vo.objectInfo);
					//trace("result:"+result);
					if(result)
					{
						currCabinet.errorFlag = false;
						
						footPoint.x = currCabinet.vo.objectInfo.x
						//trace("footPoint2:"+footPoint);
						wall.localToGlobal2(footPoint,footPoint);
						
						currCabinet.x = Base2D.sizeToScreen(footPoint.x);
						currCabinet.y = Base2D.sizeToScreen(sceneHeightSize - footPoint.y);
						
						var a:Number = 360 - wall.angles;
						currCabinet.rotation = cw.isHead ? a+180 : a;
						
						currCabinet.vo.position.x = footPoint.x;
						currCabinet.vo.position.z = footPoint.y;
						currCabinet.vo.rotation.y = currCabinet.vo.container3d.rotationY = currCabinet.rotation;
					}
					else
					{
						currCrossWall = null;
					}
				}
				else
				{
					currCrossWall = null;
				}
			}
			
			if(!currCrossWall)
			{
				currCabinet.rotation = 0;
				currCabinet.x = localPoint.x - currCabinet.width*0.5;
				currCabinet.y = localPoint.y + currCabinet.height*0.5;
				
				var pObj:ProductObject = currCabinet.vo;
				pObj.position.x = Base2D.screenToSize(currCabinet.x);
				pObj.position.z = sceneHeightSize - Base2D.screenToSize(currCabinet.y);
				//pObj.position.x = mousePoint.x - pObj.productInfo.dimensions.x * 0.5;
				//pObj.position.z = mousePoint.y + pObj.productInfo.dimensions.z * 0.5;
				
				pObj.rotation.y = pObj.container3d.rotationY = 0;
				
				if(currCabinet.wall)
				{
					if(!_flue || !_drainer || _flue.wall!=_drainer.wall)//水盆柜和灶台柜没有关联到同一墙体上
					{
						currCabinet.wall.selected = false;
					}
					currCabinet.wall = null;
				}
				
				currCabinet.errorFlag = true;
			}
		}
		
		private function endMoveCabinet(event:MouseEvent):void
		{
			//trace("endMoveCabinet");
			
			stage.removeEventListener(MouseEvent.MOUSE_MOVE,movingCabinet);
			stage.removeEventListener(MouseEvent.CLICK,endMoveCabinet);
			stage.removeEventListener(MouseEvent.MOUSE_UP,endMoveCabinet);
			
			this.scene.enable = true;
			
			currCabinet.enable = true;
			
			var obj:WallObject = currCabinet.vo.objectInfo;
			var h:int = obj.y + obj.height;
			//trace("-----"+h,obj.y,obj.height);
			
			var level:int = h < 80 ? 0 : (h < 1540 ? 1 : 2);
			scene.addProduct(currCabinet,level);
			
			if(!currCrossWall && (currCabinet==_flue || currCabinet==_drainer))
			{
				//如果水盆或灶台没有关联到墙，则清除之
				if(currCabinet==_flue)
				{
					_flue = null;
				}
				else
				{
					_drainer = null;
				}
				currCabinet.vo.dispose();
				currCabinet = null;
			}
			else
			{
				if(currCrossWall)
				{
					currCrossWall.addWallObject(currCabinet.vo.objectInfo);
					currCrossWall.initTestObject();
					
					scene.render();
				}
				
				if(currCabinet==_flue || currCabinet==_drainer)//如果刚放置好定位标志
				{
					if(_flue && _drainer)//且定位标志已全部放置好
					{
						GlobalEvent.event.dispatchLocationFlagReadyEvent();//派发定位标志全部放置完成事件
					}
				}
				
				if(!isMove)GlobalEvent.event.dispatchProductMouseUpEvent(currCabinet.vo);
			}
		}
		
		private var testObject:WallObject = new WallObject();
		private function setTestObject(x:Number,y:Number,width:Number,height:Number):void
		{
			testObject.x = x;
			testObject.y = y;
			testObject.width = width;
			testObject.height = height;
		}
		
		private function setCurrPanAngle(w1:Wall,w2:Wall=null):void
		{
			var house:House = House.getInstance();
			var a1:Number = (540-w1.angles)%360;
			if(w2)
			{
				var a2:Number = (540-w2.angles)%360;
				house.currPanAngle = (a1+a2)/2;
			}
			else
			{
				house.currPanAngle = a1;
			}
		}
		
		/**
		 * 自动创建厨柜
		 * @param drainer：水盆数据
		 * @param flue：灶台数据
		 * @param cookerHood：烟机数据
		 * @param sterilizer：消毒柜数据
		 * @param oven：烤箱数据
		 * 
		 */
		public function autoCreateCabinet(drainer:Object,flue:Object,cookerHood:Object,sterilizer:Object=null,oven:Object=null):void
		{
			//trace("0");
			if(!_flue || !_drainer)return;
			//trace("1");
			if(!_flue.wall || !_drainer.wall)return;
			//trace("2");
			
			var generalWall:Wall2D;//一般墙体，既没有灶台也没有水盆关联
			var generalCrossWall:CrossWall;
			var walls:Dictionary = currRoom2d.walls;
			
			for(var w:Wall2D in walls)
			{
				if(w.selected)//从厨房的已选中墙体中，找出一般墙体，用来创建无灶台无水盆的厨柜组合
				{
					if(w!=_flue.wall && w!=_drainer.wall)
					{
						trace("只允许有一个一般墙体");
						if(generalWall)return;//只允许有一个一般墙体
						
						generalWall = w;
						generalCrossWall = walls[w];
					}
				}
			}
			
			
			//即使水盆或灶台柜所在的墙体被用户取消了选择，而不是移动水盆和灶台标志，仍然将所在墙体设为选中状态，并在其上自动创建厨柜
			_flue.wall.selected = true;
			_flue.updateView();
			
			_drainer.wall.selected = true;
			_drainer.updateView();
			
			var flueCrossWall:CrossWall = walls[_flue.wall];
			var drainerCrossWall:CrossWall = walls[_drainer.wall];
			
			if(!generalCrossWall)//没有一般墙体
			{
				if(flueCrossWall == drainerCrossWall)//水盆和灶台放置于同一面墙体
				{
					trace("水盆和灶台放置于同一面墙体");
					setCurrPanAngle(flueCrossWall.wall);
					_autoCreateCabinet(flueCrossWall,_flue,false,_drainer);
					_createCabinetTable([[flueCrossWall]],[_drainer]);
				}
				else//水盆和灶台放置于不同墙体
				{
					if(drainerCrossWall.endCrossWall==flueCrossWall && flueCrossWall.headCrossWall==drainerCrossWall)
					{
						trace("水盆-->灶台");
						setCurrPanAngle(drainerCrossWall.wall,flueCrossWall.wall);
						_autoCreateCabinet(drainerCrossWall,null,false,_drainer,false,true);
						_autoCreateCabinet(flueCrossWall,_flue,false,null,false,false,600);
						_createCabinetTable([[drainerCrossWall,flueCrossWall]],[_drainer]);
					}
					else if(flueCrossWall.endCrossWall==drainerCrossWall && drainerCrossWall.headCrossWall==flueCrossWall)
					{
						trace("灶台-->水盆");
						setCurrPanAngle(drainerCrossWall.wall,flueCrossWall.wall);
						_autoCreateCabinet(flueCrossWall,_flue,false,null,false,true);
						_autoCreateCabinet(drainerCrossWall,null,false,_drainer,false,false,600);
						_createCabinetTable([[flueCrossWall,drainerCrossWall]],[_drainer]);
					}
					else//两个墙面不相交
					{
						trace("两个墙面不相交");
						setCurrPanAngle(flueCrossWall.wall);
						_autoCreateCabinet(flueCrossWall,_flue,false,null);
						_autoCreateCabinet(drainerCrossWall,null,false,_drainer);
						_createCabinetTable([[flueCrossWall],[drainerCrossWall]],[_flue,_drainer]);
					}
				}
			}
			else
			{
				trace("一般墙体");
				if(flueCrossWall == drainerCrossWall)//水盆和灶台放置于同一面墙体
				{
					trace("水盆和灶台放置于同一面墙体");
					if(generalCrossWall.headCrossWall==drainerCrossWall && drainerCrossWall.endCrossWall==generalCrossWall)
					{
						trace("水盆,灶台-->一般墙体");
						setCurrPanAngle(generalCrossWall.wall,flueCrossWall.wall);
						_autoCreateCabinet(flueCrossWall,_flue,false,_drainer,false,true);
						_autoCreateCabinet(generalCrossWall,null,false,null,false,false,600);
						_createCabinetTable([[flueCrossWall,generalCrossWall]],[_drainer]);
					}
					else if(generalCrossWall.endCrossWall==drainerCrossWall && drainerCrossWall.headCrossWall==generalCrossWall)
					{
						trace("一般墙体-->水盆,灶台");
						setCurrPanAngle(generalCrossWall.wall,flueCrossWall.wall);
						_autoCreateCabinet(generalCrossWall,null,false,null,false,true);
						_autoCreateCabinet(flueCrossWall,_flue,false,_drainer,false,false,600);
						_createCabinetTable([[generalCrossWall,flueCrossWall]],[_drainer]);
					}
					else//两个墙面不相交
					{
						trace("两个墙面不相交");
						setCurrPanAngle(flueCrossWall.wall);
						_autoCreateCabinet(flueCrossWall,_flue,false,_drainer);
						_autoCreateCabinet(generalCrossWall);
						_createCabinetTable([[flueCrossWall],[generalCrossWall]],[_drainer,null]);
					}
				}
				else//水盆和灶台放置于不同墙体
				{
					if(drainerCrossWall.endCrossWall==flueCrossWall && flueCrossWall.endCrossWall==generalCrossWall)
					{
						trace("水盆-->灶台-->一般墙体");
						setCurrPanAngle(flueCrossWall.wall);
						_autoCreateCabinet(drainerCrossWall,null,false,_drainer,false,true);
						_autoCreateCabinet(flueCrossWall,_flue,false,null,false,true,600);
						_autoCreateCabinet(generalCrossWall,null,false,null,false,false,600);
						_createCabinetTable([[drainerCrossWall,flueCrossWall,generalCrossWall]],[_drainer]);
					}
					else if(flueCrossWall.endCrossWall==drainerCrossWall && drainerCrossWall.endCrossWall==generalCrossWall)
					{
						trace("灶台-->水盆-->一般墙体");
						setCurrPanAngle(drainerCrossWall.wall);
						_autoCreateCabinet(flueCrossWall,_flue,false,null,false,true);
						_autoCreateCabinet(drainerCrossWall,null,false,_drainer,false,true,600);
						_autoCreateCabinet(generalCrossWall,null,false,null,false,false,600);
						_createCabinetTable([[flueCrossWall,drainerCrossWall,generalCrossWall]],[_drainer]);
					}
					else if(drainerCrossWall.endCrossWall==generalCrossWall && generalCrossWall.endCrossWall==flueCrossWall)
					{
						trace("水盆-->一般墙体-->灶台");
						setCurrPanAngle(generalCrossWall.wall);
						_autoCreateCabinet(drainerCrossWall,null,false,_drainer,false,true);
						_autoCreateCabinet(generalCrossWall,null,false,null,false,true,600);
						_autoCreateCabinet(flueCrossWall,_flue,false,null,false,false,600);
						_createCabinetTable([[drainerCrossWall,generalCrossWall,flueCrossWall]],[_drainer]);
					}
					else if(flueCrossWall.endCrossWall==generalCrossWall && generalCrossWall.endCrossWall==drainerCrossWall)
					{
						trace("灶台-->一般墙体-->水盆");
						setCurrPanAngle(generalCrossWall.wall);
						_autoCreateCabinet(flueCrossWall,_flue,false,null,false,true);
						_autoCreateCabinet(generalCrossWall,null,false,null,false,true,600);
						_autoCreateCabinet(drainerCrossWall,null,false,_drainer,false,false,600);
						_createCabinetTable([[flueCrossWall,generalCrossWall,drainerCrossWall]],[_drainer]);
					}
					else if(generalCrossWall.endCrossWall==drainerCrossWall && drainerCrossWall.endCrossWall==flueCrossWall)
					{
						trace("一般墙体-->水盆-->灶台");
						setCurrPanAngle(drainerCrossWall.wall);
						_autoCreateCabinet(generalCrossWall,null,false,null,false,true);
						_autoCreateCabinet(drainerCrossWall,null,false,_drainer,false,true,600);
						_autoCreateCabinet(flueCrossWall,_flue,false,null,false,false,600);
						_createCabinetTable([[generalCrossWall,drainerCrossWall,flueCrossWall]],[_drainer]);
					}
					else if(generalCrossWall.endCrossWall==flueCrossWall && flueCrossWall.endCrossWall==drainerCrossWall)
					{
						trace("一般墙体-->灶台-->水盆");
						setCurrPanAngle(flueCrossWall.wall);
						_autoCreateCabinet(generalCrossWall,null,false,null,false,true);
						_autoCreateCabinet(flueCrossWall,_flue,false,null,false,true,600);
						_autoCreateCabinet(drainerCrossWall,null,false,_drainer,false,false,600);
						_createCabinetTable([[generalCrossWall,flueCrossWall,drainerCrossWall]],[_drainer]);
					}
					else
					{
						trace("这是什么情况");
					}
				}
			}
		}
		
		private var tableMeshs:Vector.<CabinetTable3D> = new Vector.<CabinetTable3D>();
		
		//更新台面位置
		public function updateTableMeshsPos(dx:Number,dz:Number):void
		{
			for each(var ct:CabinetTable3D in tableMeshs)
			{
				ct.x = -dx;
				ct.z = -dz;
				trace("updateTableMeshsPos:"+ct.x,ct.z);
			}
			if(flueProduct)
			{
				flueProduct.container3d.x = flueProduct.position.x - dx;
				flueProduct.container3d.z = flueProduct.position.z - dz;
			}
			if(drainerProduct)
			{
				drainerProduct.container3d.x = drainerProduct.position.x - dx;
				drainerProduct.container3d.z = drainerProduct.position.z - dz;
			}
			/*var len:int = tableMeshs.length;
			for(var i:int=0;i<len;i++)
			{
				var m:Mesh = tableMeshs[i];
				m.x = -dx;
				m.z = -dz;
			}*/
		}
		
		//切换台面的显示状态
		public function switchCabinetTableVisible():void
		{
			for each(var ct:CabinetTable3D in tableMeshs)
			{
				ct.visible = !ct.visible;
				trace("ct.visible:"+ct.visible);
			}
			if(flueProduct)
			{
				flueProduct.container3d.visible = ct.visible;
			}
			if(drainerProduct)
			{
				drainerProduct.container3d.visible = ct.visible;
			}
			/*var len:int = tableMeshs.length;
			for(var i:int=0;i<len;i++)
			{
				var m:Mesh = tableMeshs[i];
				m.visible = !m.visible;
			}*/
		}
		
		//添加台面到三维显示
		private function addTableMeshs():void
		{
			for each(var ct:CabinetTable3D in tableMeshs)
			{
				engineManager.addRootChild(ct);
			}
			/*var len:int = tableMeshs.length;
			for(var i:int=0;i<len;i++)
			{
				var m:Mesh = tableMeshs[i];
				engineManager.addRootChild(m);
			}*/
		}
		
		//清除台面
		private function removeTableMeshs():void
		{
			while(tableMeshs.length>0)
			{
				var ct:CabinetTable3D = tableMeshs.pop();
				ct.removeEventListener(MouseEvent3D.MOUSE_DOWN,onMouseDown);
				ct.removeEventListener(MouseEvent3D.MOUSE_UP,onMouseUp);
				ct.disposeWithAnimatorAndChildren();
			}
			if(flueProduct)
			{
				flueProduct.dispose();
				flueProduct = null;
			}
			if(drainerProduct)
			{
				drainerProduct.dispose();
				drainerProduct = null;
			}
			/*var len:int = tableMeshs.length;
			for(var i:int=0;i<len;i++)
			{
				var m:Mesh = tableMeshs[i];
				engineManager.removeRootChild(m);
				m.dispose();
			}
			tableMeshs.length = 0;*/
		}
		
		//创建台面模型
		private function createTableMesh(points:Array,holePoint:Point,holes:Array=null,n:int=100,r:int=1):void
		{
			//var n:int = 2;
			if(!holes)
			{
				var p:Point = holePoint;
				var p1:Point = new Point(p.x+n,p.y+n);
				var p2:Point = new Point(p.x-n,p.y+n);
				var p3:Point = new Point(p.x-n,p.y-n);
				var p4:Point = new Point(p.x+n,p.y-n);
				holes = [p1,p2,p3,p4];
			}
			
			_createTableMesh(points,holes,r);
		}
		
		private function _createTableMesh(points:Array,holes:Array,r:int=1,segment:uint=8,height:Number=40,
										  textureURL:String="",normalURL:String="",
										  color:uint=0xDDDDDD,ambient:Number=0.8,
										  specular:Number=0.3,gloss:Number=50):void
		{
			var ct:CabinetTable3D = CabinetTableTool.createCabinetTable(points,holes,r,segment,height,textureURL,normalURL,color,ambient,specular,gloss);
			ct.material.lightPicker = engineManager.engine3d.lightPicker;
			
			//RenderUtils.setMaterial(ct,RenderUtils.getDefaultMaterial("table"));
			ct.setMaterial(this.cabinetTableDefaultMaterial);
			
			ct.y = 800;
			//ct.visible = false;
			//trace("tableMesh:"+m);
			tableMeshs.push(ct);
			
			ct.pickingCollider = PickingColliderType.AS3_FIRST_ENCOUNTERED;
			ct.mouseEnabled = ct.mouseChildren = true;
			
			ct.addEventListener(MouseEvent3D.MOUSE_DOWN,onMouseDown);
			ct.addEventListener(MouseEvent3D.MOUSE_UP,onMouseUp);
		}
		
		private function onMouseDown(e:MouseEvent3D):void
		{
			GlobalEvent.event.dispatchCabinetTableMouseDownEvent(tableMeshs);
		}
		
		private function onMouseUp(e:MouseEvent3D):void
		{
			GlobalEvent.event.dispatchCabinetTableMouseUpEvent(tableMeshs);
		}
		
		public function getCabinetTableData():String
		{
			var s:String = "{";
			s += "\"tables\":[";
			var len:int = tableMeshs.length;
			for(var i:int=0;i<len;i++)
			{
				var ct:CabinetTable3D = tableMeshs[i];
				s += ct.toJsonString() + (i<len-1?",":"");
			}
			s += "]";
			if(drainerProduct)s += getCookerProductData("drainerProduct",drainerProduct);
			if(flueProduct)s += getCookerProductData("flueProduct",flueProduct);
			s += "}";
			return s;
		}
		
		private function getCookerProductData(name:String,po:ProductObject):String
		{
			var s:String = ",\""+name+"\":" + po.toJsonString();
			return s;
		}
		
		public function createCabinetTable(cabinetTable:Object):void
		{
			//removeTableMeshs();
			
			var tables:Array = cabinetTable.tables;
			
			for each(var ctData:Object in tables)
			{
				var border:Array = getPointsArray(ctData.border);
				var hole:Array = getPointsArray(ctData.hole);
				var radius:Number = ctData.radius;
				var segment:Number = ctData.segment;
				var height:Number = ctData.height;
				var textureURL:String = ctData.textureURL;
				var normalURL:String = ctData.normalURL;
				var color:Number = ctData.color;
				var ambient:Number = ctData.ambient;
				var specular:Number = ctData.specular;
				var gloss:Number = ctData.gloss;
				
				_createTableMesh(border,hole,radius,segment,height,textureURL,normalURL,color,ambient,specular,gloss);
			}
			
			addTableMeshs();
			
			if(cabinetTable.drainerProduct!=undefined)
			{
				drainerProduct = productManager.parseProductObject(cabinetTable.drainerProduct);
				//drainerProduct.container3d.visible = false;
			}
			
			if(cabinetTable.flueProduct!=undefined)
			{
				flueProduct = productManager.parseProductObject(cabinetTable.flueProduct);
				//flueProduct.container3d.visible = false;
			}
		}
		
		private function getPointsArray(a:Array):Array
		{
			var ps:Array = [];
			var len:int = a.length;
			for(var i:int=0;i<len;i++)
			{
				var o:Object = a[i];
				var p:Point = new Point(o.x,o.y);
				ps.push(p);
			}
			return ps;
		}
		
		//计算台面数据
		private function _createCabinetTable(tables:Array,holes:Array,depth:int=600,holeWidth:int=700,holeDepth:int=400):void
		{
			//removeTableMeshs();
			
			var tlen:int = tables.length;
			
			for(var k:int=0;k<tlen;k++)
			{
				var cws:Array = tables[k];
				//trace("cws:"+cws);
				var len:int = cws.length;
				//trace("len:"+len);
				
				var points:Array = [];
				
				var cw:CrossWall = cws[0];
				var head:Point = new Point();
				var end:Point = new Point();
				offsetCrossWall(cw,depth,head,end);
				
				points.push(cw.isHead?head:end);
				
				for(var i:int=1;i<len;i++)
				{
					cw = cws[i];
					var head2:Point = new Point();
					var end2:Point = new Point();
					
					offsetCrossWall(cw,depth,head2,end2);
					
					var cp:Point = Geom.intersection(head,end,head2,end2);
					//trace("cp:"+cp);
					points.push(cp);
					
					head = head2;
					end = end2;
				}
				
				points.push(cw.isHead?end:head);
				
				points.push(turnPoint3d(cw.isHead?cw.globalEnd:cw.globalHead));
				for(i=len-2;i>=0;i--)
				{
					cw = cws[i];
					points.push(turnPoint3d(cw.isHead?cw.globalEnd:cw.globalHead));
				}
				points.push(turnPoint3d(cw.isHead?cw.globalHead:cw.globalEnd));
				
				//trace("points:"+points);
				
				var pdt:Product2D = holes[k];
				if(pdt==_drainer)
				{
					holeWidth = drainerProduct.objectInfo.width;
					holeDepth = drainerProduct.objectInfo.depth;
					
					var ww:Number = pdt.wall.vo.width*0.5 + depth*0.5;
					var x:int = pdt.vo.objectInfo.x;
					var y:int = pdt.vo.objectInfo.crossWall.isHead?-ww:ww;
					//y = -ww;
					var dx:int = holeWidth*0.5;
					var dy:int = holeDepth*0.5;
					trace("_drainer postion:"+x+"x"+y);
					trace("_drainer hole:"+dx+"x"+dy);
					
					var p1:Point = new Point(x+dx,y+dy);
					var p2:Point = new Point(x-dx,y+dy);
					var p3:Point = new Point(x-dx,y-dy);
					var p4:Point = new Point(x+dx,y-dy);
					
					var wall:Wall = pdt.wall.vo;
					wall.localToGlobal2(p1,p1);
					wall.localToGlobal2(p2,p2);
					wall.localToGlobal2(p3,p3);
					wall.localToGlobal2(p4,p4);
					
					var hole:Array = [p1,p2,p3,p4];
					
					var p:Point;// = pdt.wall.vo.localToGlobal2(new Point(pdt.vo.objectInfo.x,y));
					//p = new Point(pdt.vo.position.x,pdt.vo.position.z);
					createTableMesh(points,p,hole,200,30);
				}
				else
				{
					var p0:Point = points[0];
					p1 = points[2];
					p = new Point(p0.x+(p1.x-p0.x)*0.5,p0.y+(p1.y-p0.y)*0.5);
					createTableMesh(points,p,null,2);
				}
			}
			
			addTableMeshs();
		}
		
		//三维点转换为二维点，去掉了高度信息
		private function turnPoint3d(p3d:Point3D):Point
		{
			return new Point(p3d.x,p3d.z);
		}
		
		//计算从一个墙面向外偏移指定距离后的线段位置（全局坐标位置）
		private function offsetCrossWall(cw:CrossWall,offset:int,head:Point,end:Point):void
		{
			var h:Point3D = cw.localHead;
			head.x = h.x;
			head.y = h.z>0?h.z+offset:h.z-offset;
			cw.wall.localToGlobal2(head,head);
			
			var e:Point3D = cw.localEnd;
			end.x = e.x;
			end.y = e.z>0?e.z+offset:e.z-offset;
			cw.wall.localToGlobal2(end,end);
		}
		
		//布置厨柜
		//mode:center[厨柜整体居中],head[厨柜紧靠头部],end[厨柜紧靠尾部],offset[指定偏移量]
		//type:ground[地柜],wall[吊柜]
		private function assignCabinet(cw:CrossWall,list:Array,start:Number,end:Number,type:String,mode:String,offset:int=0):void
		{
			var space:Number = list.pop();
			if(mode=="center")
			{
				start += space*0.5;
			}
			else if(mode=="end")
			{
				start += space;
			}
			else if(mode=="offset")
			{
				start += offset;
			}
			
			var len:int = list.length;
			for(var i:int;i<len;i++)
			{
				var w:int = list[i];
				start += w;
				createCabinetByWidth(cw,type,w,start);
			}
		}
		
		//创建指定宽度的厨柜
		private function createCabinetByWidth(cw:CrossWall,type:String,width:int,x:Number):void
		{
			var cabinets:Array = (type=="ground")?groundCabinets:wallCabinets;
			var dict:Dictionary = (type=="ground")?groundWidthDict:wallWidthDict;
			var index:int = dict[width];//获取特定宽度厨柜的数据索引
			var o:Object = this.getCabinetData(cabinets,index);//取出厨柜数据
			if(type=="ground")
			{
				this.createGroundCabinet(o,cw,x);//创建地柜
			}
			else
			{
				this.createWallCabinet(o,cw,x);//创建吊柜
			}
		}
		
		//添加转角柜
		private function addCornerCabinet(cw:CrossWall,type:String,isHead:Boolean):void
		{
			var cabinets:Array = (type=="ground")?groundCabinets:wallCabinets;
			var index:int = (type=="ground")?25:9;
			var y:int = (type=="ground")?0:1540;
			var xOffset:int = (type=="ground")?100:10;
			
			var o:Object = getCabinetData(cabinets,index);
			var width:int = o.width;
			var height:int = o.height;
			var start:int  = isHead?cw.localHead.x+xOffset+width:cw.localEnd.x-xOffset;
			
			this.setTestObject(start,y,width,height);
			
			var result:Boolean = isHead?cw.testAutoAddToEnd(testObject,start):cw.testAutoAddToHead(testObject,start);
			//trace("----addCornerCabinet index:"+cw.wall.index+" result:"+result+" x:"+start+" width:"+width);
			
			if(result)
			{
				start = testObject.x;
				if(type=="ground")
				{
					createGroundCabinet(o,cw,start);
				}
				else
				{
					createWallCabinet(o,cw,start);
				}
			}
		}
		
		//测试墙面上是否有足够的空间来放置物体，并在testObject中返回可用的位置
		private function testWallObject(cw:CrossWall,width:int,start:Number,yPos:int=1540):Boolean
		{
			start += width*0.5;
			this.setTestObject(start,yPos,width,720);
			
			var result:Boolean = cw.testAutoAddToEnd(testObject,start);
			if(!result)result = cw.testAutoAddToHead(testObject,start);
			
			return result;
		}
		
		private function addCookerProduct(o:Object,cw:CrossWall,flag:WallObject):ProductObject
		{
			var id:int = o.id;
			var file:String = o.file;
			var width:int = o.width;
			var height:int = o.height;
			var depth:int = o.depth;
			var name:String = o.label;
			
			var oid:int = ProductObject.getNextIndex();
			
			var vo:ProductObject = productManager.addProductObject(oid,name,id,file);
			//this.createProduct(vo);\
			var x:Number = flag.x;
			var n:int = cw.wall.width*0.5+300;
			var y:Number = cw.isHead?-n:n;
			var p:Point = new Point(x,y);
			cw.wall.localToGlobal2(p,p);
			
			vo.position.x = p.x;
			vo.position.y = 840;
			vo.position.z = p.y;
			
			var a:Number = 360 - cw.wall.angles;
			vo.rotation.y = vo.container3d.rotationY = cw.isHead ? a+180 : a;
			
			var wo:WallObject = new WallObject();
			wo.object = vo;
			vo.objectInfo = wo;
			wo.width = width;
			wo.height = height;
			wo.depth = depth;
			
			return vo;
		}
		
		private var flueProduct:ProductObject;
		private var drainerProduct:ProductObject
		
		//添加水盆柜、灶台柜、拉篮柜、抽油烟机，
		private function addCookerHood(cw:CrossWall,drainer:Product2D,flue:Product2D,appliance:Boolean):void
		{
			if(drainer && flue)
			{
				
			}
			else if(flue)
			{
				var start:int  = flue.vo.objectInfo.x-flue.vo.objectInfo.width*0.5;
				var xPos:Number;
				
				if(testWallObject(cw,1500,start))//一个900的灶台柜，两个300的拉篮柜
				{
					xPos = testObject.x;
					flue.vo.objectInfo.x = xPos-750;
					
					var o:Object = getCabinetData(cookerProducts,1);//抽油烟机
					createWallCabinet(o,cw,xPos-750+o.width*0.5);
					
					o = getCabinetData(groundCabinets,12);//拉篮柜
					var o2:Object = getCabinetData(groundCabinets,19);//灶台柜
					createGroundCabinet(o,cw,xPos);
					createGroundCabinet(o2,cw,xPos-300);
					createGroundCabinet(o,cw,xPos-1200);
				}
				else if(testWallObject(cw,1400,start))//一个800的灶台柜，两个300的拉篮柜
				{
					xPos = testObject.x;
					flue.vo.objectInfo.x = xPos-700;
					
					o = getCabinetData(cookerProducts,1);//抽油烟机
					createWallCabinet(o,cw,xPos-700+o.width*0.5);
					
					o = getCabinetData(groundCabinets,12);//拉篮柜
					o2 = getCabinetData(groundCabinets,19);//灶台柜
					createGroundCabinet(o,cw,xPos);
					createGroundCabinet(o2,cw,xPos-300);
					createGroundCabinet(o,cw,xPos-1100);
				}
				
				o = getCabinetData(cookerProducts,3);
				flueProduct = addCookerProduct(o,cw,flue.vo.objectInfo);
				//flueProduct.container3d.visible = false;
			}
			else
			{
				start  = drainer.vo.objectInfo.x-drainer.vo.objectInfo.width*0.5;
				
				if(testWallObject(cw,900,start))//900的水盆柜
				{
					xPos = testObject.x;
					drainer.vo.objectInfo.x = xPos-450;
					
					o = getCabinetData(groundCabinets,17);
					createGroundCabinet(o,cw,xPos);
				}
				else if(testWallObject(cw,800,start))//800的水盆柜
				{
					xPos = testObject.x;
					drainer.vo.objectInfo.x = xPos-400;
					
					o = getCabinetData(groundCabinets,16);
					createGroundCabinet(o,cw,xPos);
				}
				
				o = getCabinetData(cookerProducts,2);
				drainerProduct = addCookerProduct(o,cw,drainer.vo.objectInfo);
				//drainerProduct.container3d.visible = false;
			}
			
			productManager.loadProduct();
		}
		
		private var bigCabinets:Array = [800,900];
		private var smallCabinets:Array = [300,400,450,500];
		private var smallCabinets2:Array = [300,400,450,600];
		
		//开始自动创建厨柜
		private function _autoCreateCabinet(cw:CrossWall,
										flue:Product2D=null,//灶台
										appliance:Boolean=false,//灶台下是否放置烤箱
										drainer:Product2D=null,//水盆
										headCorner:Boolean=false,//头部是否放置转角柜
										endCorner:Boolean=false,//尾部是否放置转角柜
										startOffset:int=0,//头部起始偏移
										endOffset:int=0):void//尾部起始偏移
		{
			//return;
			var x0:Number = cw.localHead.x + startOffset;
			var x1:Number = cw.localEnd.x - endOffset;
			var x00:Number,x11:Number;
			
			var i:int;
			
			cw.initTestObject();
			if(headCorner)
			{
				addCornerCabinet(cw,"ground",true);//墙首转角地柜
				addCornerCabinet(cw,"wall",true);//墙首转角吊柜
			}
			
			if(endCorner)
			{
				addCornerCabinet(cw,"ground",false);//墙尾转角地柜
				addCornerCabinet(cw,"wall",false);//墙尾转角吊柜
			}
			
			cw.initTestObject();
			
			if(flue || drainer)
			{
				this.addCookerHood(cw,drainer,flue,appliance);
			}
			
			cw.initTestObject();
			
			var gos:Array = [];
			cw.getGroundObjectOfPos(x0,x1,gos);
			
			var len:int = gos.length;
			
			//trace("groundObjectsNum:"+len);//13906011621
			
			if(len==0)
			{
				var a:Array = TestNumer.matchGroupSize(x1 - x0,bigCabinets,smallCabinets);
				assignCabinet(cw,a,x0,x1,"ground","center");
			}
			else
			{
				var wo:WallObject = gos[0];
				//trace("wo x:"+wo.x+" width:"+wo.width);
				var wo2:WallObject = gos[len-1];
				//trace("wo2 x:"+wo2.x+" width:"+wo2.width);
				var mode:String,mode0:String,mode1:String;
				
				if(wo.x-wo.width-x0>300)
				{
					//trace("wo.object:"+wo.object);
					//trace("wo2.object:"+wo2.object);
					//trace("wo==wo2:"+(wo==wo2));
					
					if(wo.object is WallHole)//障碍物是墙洞时，要远离墙洞wo==wo2 && 
					{
						mode0 = "head";
					}
					else//否则，贴紧障碍物
					{
						mode0 = "end";
					}
					x11 = wo.x - wo.width;
					a = TestNumer.matchGroupSize(x11-x0,bigCabinets,smallCabinets);
					assignCabinet(cw,a,x0,x11,"ground",mode0);
				}
				
				if(x1-wo2.x>300)
				{
					if(wo2.object is WallHole)//障碍物是墙洞时，要远离墙洞wo==wo2 && 
					{
						mode1 = "end";
					}
					else//否则，贴紧障碍物
					{
						mode1 = "head";
					}
					x00 = wo2.x;
					a = TestNumer.matchGroupSize(x1-x00,bigCabinets,smallCabinets);
					assignCabinet(cw,a,x00,x1,"ground",mode1);
				}
				//trace("mode0:"+mode0);
				//trace("mode1:"+mode1);
				
				for(i=1;i<len;i++)
				{
					wo = gos[i-1];
					wo2 = gos[i];
					
					if(len==2)//只有两个障碍物时
					{
						if(mode0=="end")mode = "head";//贴紧前方障碍物
						else if(mode1=="head")mode = "end";//贴紧后方障碍物
						else
							mode = "center";
					}
					else if(wo.object is WallHole && wo2.object is WallHole)//前后障碍物都是墙洞时，厨柜在两个墙洞之间居中放置
					{
						mode = "center";
					}
					else if(wo.object is WallHole && !(wo2.object is WallHole))//前面是墙洞，后面不是墙洞时，厨柜贴紧后面的障碍物放置
					{
						mode = "end";
					}
					else if(!(wo.object is WallHole) && wo2.object is WallHole)//前面不是墙洞，后面是墙洞时，厨柜贴紧前面的障碍物放置
					{
						mode = "head";
					}
					else//前后都不是墙洞
					{
						if(i==1 && !mode0)//障碍物之前没有物品，贴紧后方障碍物
						{
							mode = "end";
						}
						else if(i==len-1 && !mode1)//障碍物之后没有物品，贴紧前方障碍物
						{
							mode = "head";
						}
						else//其它情况，厨柜居中
						{
							mode = "center";
						}
					}
					//trace(i+" mode:"+mode);
					
					if(wo2.x-wo2.width-wo.x>300)
					{
						x00 = wo.x;
						x11 = wo2.x - wo2.width;
						a = TestNumer.matchGroupSize(x11-x00,bigCabinets,smallCabinets);
						assignCabinet(cw,a,x00,x11,"ground",mode);
					}
				}
			}
			
			if(startOffset>0)x0 = cw.localHead.x + 350;
			if(endOffset>0)x1 = cw.localEnd.x - 350;
			
			var wos:Array = [];
			cw.getWallObjectOfPos(x0,x1,wos);
			
			len = wos.length;
			
			//trace("wallObjectsNum:"+len);
			
			if(len==0)
			{
				a = TestNumer.matchGroupSize(x1 - x0,bigCabinets,smallCabinets2);
				assignCabinet(cw,a,x0,x1,"wall","center");
			}
			else
			{
				wo = wos[0];
				wo2 = wos[len-1];
				
				if(wo.x-wo.width-x0>300)
				{
					if(wo==wo2 && wo.object is WallHole)//障碍物是墙洞时，要远离墙洞
					{
						mode0 = "head";
					}
					else//否则，贴紧障碍物
					{
						mode0 = "end";
					}
					x11 = wo.x - wo.width;
					a = TestNumer.matchGroupSize(x11-x0,bigCabinets,smallCabinets2);
					assignCabinet(cw,a,x0,x11,"wall",mode0);
				}
				else
				{
					mode0 = null;
				}
				
				if(x1-wo2.x>300)
				{
					if(wo==wo2 && wo.object is WallHole)//障碍物是墙洞时，要远离墙洞
					{
						mode1 = "end";
					}
					else//否则，贴紧障碍物
					{
						mode1 = "head";
					}
					x00 = wo2.x;
					a = TestNumer.matchGroupSize(x1-x00,bigCabinets,smallCabinets2);
					assignCabinet(cw,a,x00,x1,"wall",mode1);
				}
				else
				{
					mode1 = null;
				}
				
				for(i=1;i<len;i++)
				{
					wo = wos[i-1];
					wo2 = wos[i];
					
					if(len==2)//只有两个障碍物时
					{
						if(mode0=="end")mode = "head";//贴紧前方障碍物
						else if(mode1=="head")mode = "end";//贴紧后方障碍物
						else
							mode = "center";
					}
					else if(wo.object is WallHole && wo2.object is WallHole)//前后障碍物都是墙洞时，厨柜在两个墙洞之间居中放置
					{
						mode = "center";
					}
					else if(wo.object is WallHole && !(wo2.object is WallHole))//前面是墙洞，后面不是墙洞时，厨柜贴紧后面的障碍物放置
					{
						mode = "end";
					}
					else if(!(wo.object is WallHole) && wo2.object is WallHole)//前面不是墙洞，后面是墙洞时，厨柜贴紧前面的障碍物放置
					{
						mode = "head";
					}
					else//前后都不是墙洞
					{
						if(i==1 && !mode0)//障碍物之前没有物品，贴紧后方障碍物
						{
							mode = "end";
						}
						else if(i==len-1 && !mode1)//障碍物之后没有物品，贴紧前方障碍物
						{
							mode = "head";
						}
						else//其它情况，厨柜居中
						{
							mode = "center";
						}
					}
					
					if(wo2.x-wo2.width-wo.x>300)
					{
						x00 = wo.x;
						x11 = wo2.x - wo2.width;
						a = TestNumer.matchGroupSize(x11-x00,bigCabinets,smallCabinets2);
						assignCabinet(cw,a,x00,x11,"wall",mode);
					}
				}
			}
			
			cw.initTestObject();
			cw.wall.isChanged = true;
			
			scene.render();
		}
		
		/*public function autoCreateCabinet3():void
		{
			//创建水槽柜
			if(_drainer && _drainer.vo.objectInfo.crossWall)
			{
				var ob:WallObject = _drainer.vo.objectInfo;
				var cw:CrossWall = ob.crossWall;
				cw.initTestObject();
				
				var x:Number = ob.x + 400;
				createCabinet("516","cabinet_516_800x720x570.pdt","text",cw,x);
				
				createToHead(cw,x-800);
				createToEnd(cw,x);
				
				autoCreateWallCabinet(cw,cw.localEnd.x);
			}
			
			//根据烟道所在，创建灶台柜
			if(_flue && _flue.vo.objectInfo.crossWall)
			{
				ob = _flue.vo.objectInfo;
				var cw2:CrossWall = ob.crossWall;
				
				if(cw2!=cw)//灶台柜与水盆柜不在同一个墙面上
				{
					cw2.initTestObject();
					
					if(ob.x>(cw2.localEnd.x-cw2.localHead.x)/2+cw2.localHead.x)//烟道在墙面的后半部分
					{
						//x = ob.x - ob.width;
						x = cw2.localEnd.x-570;
						
						createCabinet("526","cabinet_526_800x720x570.pdt","text",cw2,x);
						createToHead(cw2,x-800);
						autoCreateWallCabinet(cw2,x);
					}
					else//烟道在墙面的前半部分
					{
						//x = ob.x + 800;
						x = cw2.localHead.x + 570 + 800;
						createCabinet("526","cabinet_526_800x720x570.pdt","text",cw2,x);
						createToEnd(cw2,x);
						autoCreateWallCabinet(cw2,cw2.localEnd.x);
					}
				}
				else//灶台柜与水盆柜在同一个墙面上时
				{
					if(ob.x>(cw2.localEnd.x-cw2.localHead.x)/2+cw2.localHead.x)//烟道在墙面的后半部分
					{
						cw2 = cw2.endCrossWall;
						cw2.initTestObject();
						
						x = cw2.localHead.x + 570 + 800;
						createCabinet("526","cabinet_526_800x720x570.pdt","text",cw2,x);
						createToEnd(cw2,x);
						autoCreateWallCabinet(cw2,cw2.localEnd.x);
					}
					else//烟道在墙面的前半部分
					{
						cw2 = cw2.headCrossWall;
						cw2.initTestObject();
						
						x = cw2.localEnd.x - 570;
						
						createCabinet("526","cabinet_526_800x720x570.pdt","text",cw2,x);
						createToHead(cw2,x-800);
						autoCreateWallCabinet(cw2,cw2.localEnd.x - 330);
					}
				}
			}
		}*/
		
		/*private function autoCreateWallCabinet(cw:CrossWall,start:int):void
		{
			//if(cw.localEnd.x-start<330 && cw.endCrossWall.wallObjects.length>0)start=cw.localEnd.x-330;
			
			var x0:Number = cw.localHead.x;
			var dx:Number = start-x0;
			if(dx>900)
			{
				var o:Object = getCabinetData(wallCabinets);
				var width:int = o.width;
				var height:int = o.height;
				this.setTestObject(0,1540,width,height);
				var result:Boolean = cw.testAutoAddToHead(testObject,start);
				if(result)
				{
					start = testObject.x;
					
					var n:int = createWallCabinet(o,cw,start);
					autoCreateWallCabinet(cw,start-n);
				}
			}
			else
			{
				var wos:Array = [];
				cw.getWallObjectOfPos(x0,start,wos);
				if(wos.length>0)
				{
					var wo:WallObject = wos[wos.length-1];
					dx = start - wo.x;
				}
				
				if(dx>=800)
				{
					createWallCabinet(getCabinetData(wallCabinets,4),cw,start);
				}
				else if(dx>=600)
				{
					createWallCabinet(getCabinetData(wallCabinets,3),cw,start);
				}
				else if(dx>=450)
				{
					createWallCabinet(getCabinetData(wallCabinets,2),cw,start);
				}
				else if(dx>=400)
				{
					createWallCabinet(getCabinetData(wallCabinets,1),cw,start);
				}
				else if(dx>=300)
				{
					createWallCabinet(getCabinetData(wallCabinets,0),cw,start);
				}
			}
		}*/
		
		/*private function createToEnd(cw:CrossWall,start:int):void
		{
			var x1:Number = cw.localEnd.x;
			var dx:Number = x1 - start;
			if(dx>900)
			{
				var o:Object = getCabinetData(groundCabinets);
				var width:int = o.width;
				var height:int = o.height;
				this.setTestObject(0,0,width,height);
				var result:Boolean = cw.testAutoAddToEnd(testObject,start+width);
				if(result)
				{
					start = testObject.x;
					
					createGroundCabinet(o,cw,start);
					createToEnd(cw,start);
				}
			}
			else
			{
				var gos:Array = [];
				cw.getGroundObjectOfPos(start,x1,gos);
				if(gos.length>0)
				{
					var wo:WallObject = gos[0];
					dx = wo.x-wo.width-start;
				}
				
				if(dx>=800)
				{
					createGroundCabinet(getCabinetData(groundCabinets,4),cw,start+800);
				}
				else if(dx>=600)
				{
					createGroundCabinet(getCabinetData(groundCabinets,3),cw,start+500);
				}
				else if(dx>=450)
				{
					createGroundCabinet(getCabinetData(groundCabinets,2),cw,start+450);
				}
				else if(dx>=400)
				{
					createGroundCabinet(getCabinetData(groundCabinets,1),cw,start+400);
				}
				else if(dx>=300)
				{
					createGroundCabinet(getCabinetData(groundCabinets,0),cw,start+300);
				}
			}
		}*/
		
		/*private function createToHead(cw:CrossWall,start:int):void
		{
			var x0:Number = cw.localHead.x;
			var dx:Number = start-x0;
			if(dx>900)
			{
				var o:Object = getCabinetData(groundCabinets);
				var width:int = o.width;
				var height:int = o.height;
				this.setTestObject(0,0,width,height);
				var result:Boolean = cw.testAutoAddToHead(testObject,start);
				if(result)
				{
					start = testObject.x;
					
					var n:int = createGroundCabinet(o,cw,start);
					createToHead(cw,start-n);
				}
			}
			else
			{
				var gos:Array = [];
				cw.getGroundObjectOfPos(x0,start,gos);
				if(gos.length>0)
				{
					var wo:WallObject = gos[gos.length-1];
					dx = start - wo.x;
				}
				
				if(dx>=800)
				{
					createGroundCabinet(getCabinetData(groundCabinets,4),cw,start);
				}
				else if(dx>=500)
				{
					createGroundCabinet(getCabinetData(groundCabinets,3),cw,start);
				}
				else if(dx>=450)
				{
					createGroundCabinet(getCabinetData(groundCabinets,2),cw,start);
				}
				else if(dx>=400)
				{
					createGroundCabinet(getCabinetData(groundCabinets,1),cw,start);
				}
				else if(dx>=300)
				{
					createGroundCabinet(getCabinetData(groundCabinets,0),cw,start);
				}
				else if(dx>=200)
				{
					//createCabinet2(getGroundCabinetData(),cw,start);
				}
			}
		}*/
		
		private function getCabinetData(cabinets:Array,index:int=-1):Object
		{
			index = (index<0 || index>cabinets.length-1) ? int(Math.random()*cabinets.length) : index;
			var o:Object = cabinets[index];
			//var h:int = o.height;
			//if(h>720)o=getCabinetData();
			return o;
		}
		
		/**
		 * 添加新橱柜前，检测所添加区段是否可用，
		 * 如不可用，检查区段中的物体所在，并避让后，检测新区段是否可用
		 * 直到有可用区段，添加入新橱柜
		 * 
		 */
		private function createGroundCabinet(o:Object,cw:CrossWall,x:int):int
		{
			var id:int = o.id;
			var file:String = o.file;
			var width:int = o.width;
			//trace("------createGroundCabinet:"+width);
			createCabinet(id,file,"text",cw,x,0,file,false,width,550);
			return width;
		}
		
		private function createWallCabinet(o:Object,cw:CrossWall,x:int):int
		{
			var id:int = o.id;
			var file:String = o.file;
			var width:int = o.width;
			//var height:int = o.height;
			//this.setTestObject(0,1540,width,height);
			//trace("------createWallCabinet"+width);
			createCabinet(id,file,"text",cw,x,1540,file,false,width,330);
			return width;
		}
		
		/*public function autoCreateCabinet2():void
		{
			rooms = scene.currFloor.rooms;
			for each(var room2d:Room2D in rooms)
			{
				var ws:Dictionary = room2d.walls;
				for(var w:Wall2D in ws)
				{
					if(w.selected)
					{
						var cw:CrossWall = ws[w];
						var wall:Wall = cw.wall;
						var xStart:Number = cw.isHead ? wall.groundFrontHead.x : wall.groundBackHead.x;
						var xEnd:Number = cw.isHead ? wall.groundFrontEnd.x : wall.groundBackEnd.x;
						
						var cabinets:Array = w.cabinets.concat();
						var len:int = cabinets.length;
						//trace("=============="+cabinets,len>0);10/20 9:42 62597034
						
						if(len>0)
						{
							var xWall:int = cab.vo.objectInfo.x;
							var cab:Cabinet2D = cabinets[0];
							xEnd = xWall-cab.productWidth;
							//trace("cab.xWall:"+cab.xWall+" cab.productWidth:"+cab.productWidth);
							_autoCreateCabinet(cw,xStart,xEnd);
							
							for(var i:int=0;i<len-1;i++)
							{
								xStart = cabinets[i].xWall;
								cab = cabinets[i+1];
								//trace("cab.xWall:"+cab.xWall+" cab.productWidth:"+cab.productWidth);
								xEnd = xWall-cab.productWidth;
								_autoCreateCabinet(cw,xStart,xEnd);
							}
							
							cab = cabinets[len-1];
							//trace("cab.xWall:"+cab.xWall+" cab.productWidth:"+cab.productWidth);
							xStart = xWall;
							xEnd = cw.isHead ? wall.groundFrontEnd.x : wall.groundBackEnd.x;
							_autoCreateCabinet(cw,xStart,xEnd);
						}
						else
						{
							_autoCreateCabinet(cw,xStart,xEnd);
						}
					}
				}
			}
		}*/
		
		/*private function _autoCreateCabinet(cw:CrossWall,xStart:Number,xEnd:Number):void
		{
			//trace("_autoCreateCabinet xStart:"+xStart+" _xEnd:"+xEnd);
			var n:Number = xStart;
			while(n<xEnd)
			{
				var tn:Number = xEnd-n;
				if(tn>=800)
				{
					n += 800;
					createCabinet("506","cabinet_506_800x720x570.pdt","text",cw,n);
				}
				else if(tn>=500)
				{
					n += 500;
					createCabinet("504","cabinet_504_500x720x570.pdt","text",cw,n);
				}
				else if(tn>=450)
				{
					n += 450;
					createCabinet("503","cabinet_503_450x720x570.pdt","text",cw,n);
				}
				else if(tn>=400)
				{
					n += 400;
					createCabinet("502","cabinet_502_400x720x570.pdt","text",cw,n);
				}
				else if(tn>=300)
				{
					n += 300;
					createCabinet("501","cabinet_501_300x720x570.pdt","text",cw,n);
				}
				else
				{
					n = xEnd;
				}
			}
		}*/
		
		/*private var waterGroundObjects:Array;//水盆位置地柜组合
		private var waterWallObjects:Array;//水盆位置吊柜组合
		private var fireGroundObjects:Array;//灶台位置地柜组合
		private var fireWallObjects:Array;//灶台位置吊柜组合
		private var generalGroundObjects:Array;//无水盆无灶台位置地柜组合
		private var generalWallObjects:Array;//无水盆无灶台位置吊柜组合*/
		
		/*private var waterGroundGroups:XML;//水盆位置地柜组合
		private var waterWallGroups:XML;//水盆位置吊柜组合
		private var fireGroundGroups:XML;//灶台位置地柜组合
		private var fireWallGroups:XML;//灶台位置吊柜组合
		private var generalGroundGroups:XML;//无水盆无灶台位置地柜组合
		private var generalWallGroups:XML;*///无水盆无灶台位置吊柜组合
		
		/*private function initBaseGroups():void
		{
			waterGroundGroups = 
				<data>
					<core>16,17</core>
					<sides>3</sides>
					<middle>3,2</middle>
					<ends>1,0</ends>
					<corner>25</corner>
				</data>;
			
			waterWallGroups = 
				<data>
					<core>3</core>
					<sides>3</sides>
					<middle>3</middle>
					<ends>2,1,0</ends>
					<corner>9</corner>
				</data>;
			
			fireGroundGroups = 
				<data>
					<core></core>
					<sides></sides>
					<middle></middle>
					<ends></ends>
					<corner></corner>
				</data>;
			
			fireWallGroups = 
				<data>
					<core></core>
					<sides></sides>
					<middle></middle>
					<ends></ends>
					<corner></corner>
				</data>;
			generalGroundGroups = 
				<data>
					<core></core>
					<sides></sides>
					<middle></middle>
					<ends></ends>
					<corner></corner>
				</data>;
			
			generalWallGroups = 
				<data>
					<core></core>
					<sides></sides>
					<middle></middle>
					<ends></ends>
					<corner></corner>
				</data>;
		}*/
		
		private var groundCabinets:Array;
		
		private var wallCabinets:Array;
		
		private var cookerProducts:Array;
		
		private var groundWidthDict:Dictionary = new Dictionary();
		
		private var wallWidthDict:Dictionary = new Dictionary();
		
		public function replaceCurrCabinet():void
		{
			if(!this.currCabinet)return;
			productManager.replaceProductObject(currCabinet.vo,515,"cabinet_515_600x720x570.pdt","");
			currCabinet = null;
		}
		
		private function initCabinetData():void
		{
			groundCabinets = [
					{id:"501",file:"cabinet_501_300x720x570.pdt" ,width:"300",height:"720" ,label:"单门地柜"},//0
					{id:"502",file:"cabinet_502_400x720x570.pdt" ,width:"400",height:"720" ,label:"单门地柜"},//1
					{id:"503",file:"cabinet_503_450x720x570.pdt" ,width:"450",height:"720" ,label:"单门地柜"},//2
					{id:"504",file:"cabinet_504_500x720x570.pdt" ,width:"500",height:"720" ,label:"单门地柜"},//3
					{id:"506",file:"cabinet_506_800x720x570.pdt" ,width:"800",height:"720" ,label:"双门地柜"},//4
					{id:"507",file:"cabinet_507_900x720x570.pdt" ,width:"900",height:"720" ,label:"双门地柜"},//5
					{id:"513",file:"cabinet_513_450x720x570.pdt" ,width:"450",height:"720" ,label:"小小大抽屉柜"},//6
					{id:"515",file:"cabinet_515_600x720x570.pdt" ,width:"600",height:"720" ,label:"小小大抽屉柜"},//7
					{id:"546",file:"cabinet_546_800x720x570.pdt" ,width:"800",height:"720" ,label:"二平分抽屉地柜"},//8
					{id:"547",file:"cabinet_547_900x720x570.pdt" ,width:"900",height:"720" ,label:"二平分抽屉地柜"},//9
					{id:"525",file:"cabinet_525_600x720x570.pdt" ,width:"600",height:"720" ,label:"消毒柜"},//10
					{id:"510",file:"cabinet_510_200x720x570.pdt" ,width:"200",height:"720" ,label:"调味拉篮柜"},//11
					{id:"511",file:"cabinet_511_300x720x570.pdt" ,width:"300",height:"720" ,label:"调味拉篮柜"},//12
					{id:"512",file:"cabinet_512_400x720x570.pdt" ,width:"400",height:"720" ,label:"调味拉篮柜"},//13
					{id:"536",file:"cabinet_536_800x720x570.pdt" ,width:"800",height:"720" ,label:"二平分拉篮柜"},//14
					{id:"537",file:"cabinet_537_900x720x570.pdt" ,width:"900",height:"720" ,label:"二平分拉篮柜"},//15
					{id:"516",file:"cabinet_516_800x720x570.pdt" ,width:"800",height:"720" ,label:"双门水槽柜"},//16
					{id:"517",file:"cabinet_517_900x720x570.pdt" ,width:"900",height:"720" ,label:"双门水槽柜"},//17
					{id:"526",file:"cabinet_526_800x720x570.pdt" ,width:"800",height:"720" ,label:"双门炉台柜"},//18
					{id:"527",file:"cabinet_527_900x720x570.pdt" ,width:"900",height:"720" ,label:"双门炉台柜"},//19
					{id:"703",file:"cabinet_703_450x1390x570.pdt",width:"450",height:"1390",label:"单木门中高柜"},//20
					{id:"705",file:"cabinet_705_600x1390x570.pdt",width:"600",height:"1390",label:"单木门中高柜"},//21
					{id:"805",file:"cabinet_805_600x2110x570.pdt",width:"600",height:"2110",label:"门+门高柜"},//22
					{id:"715",file:"cabinet_715_600x1390x570.pdt",width:"600",height:"1390",label:"烤箱、微波炉功能柜"},//23
					{id:"815",file:"cabinet_815_600x2110x570.pdt",width:"600",height:"2110",label:"烤箱、微波炉功能柜"},//24
					{id:"557",file:"cabinet_557_900x720x570.pdt" ,width:"900",height:"720" ,label:"单门转角地柜"}//25
			];
			
			groundWidthDict[300] = 0;
			groundWidthDict[400] = 1;
			groundWidthDict[450] = 2;
			groundWidthDict[500] = 3;
			groundWidthDict[600] = 10;
			groundWidthDict[800] = 4;
			groundWidthDict[900] = 5;
			
			wallCabinets = [
				{id:"601",file:"cabinet_601_300x720x330.pdt",width:"300",height:"720",label:"单门吊柜"},//0
				{id:"602",file:"cabinet_602_400x720x330.pdt",width:"400",height:"720",label:"单门吊柜"},//1
				{id:"603",file:"cabinet_603_450x720x330.pdt",width:"450",height:"720",label:"单门吊柜"},//2
				{id:"605",file:"cabinet_605_600x720x330.pdt",width:"600",height:"720",label:"单门吊柜"},//3
				{id:"606",file:"cabinet_606_800x720x330.pdt",width:"800",height:"720",label:"双门吊柜"},//4
				{id:"607",file:"cabinet_607_900x720x330.pdt",width:"900",height:"720",label:"双门吊柜"},//5
				{id:"616",file:"cabinet_616_800x720x330.pdt",width:"800",height:"720",label:"双上翻门吊柜"},//6
				{id:"617",file:"cabinet_617_900x720x330.pdt",width:"900",height:"720",label:"双上翻门吊柜"},//7
				{id:"615",file:"cabinet_615_600x720x330.pdt",width:"600",height:"720",label:"微波炉吊柜"},//8
				{id:"626",file:"cabinet_626_800x720x330.pdt",width:"800",height:"720",label:"单门转角吊柜"}//9
				//{id:"1101",file:"cooker_hood_1101.pdt",width:"800",height:"700",label:"抽油烟机"},//10
				//{id:"1102",file:"cooker_hood_1102_CXW-268-L1.pdt",width:"896",height:"860",label:"抽油烟机"}//11
			];
			
			wallWidthDict[300] = 0;
			wallWidthDict[400] = 1;
			wallWidthDict[450] = 2;
			wallWidthDict[600] = 3;
			wallWidthDict[800] = 4;
			wallWidthDict[900] = 5;
			
			cookerProducts = [
				{id:"1101",file:"cooker_hood_1101.pdt",width:"800",height:"700",label:"抽油烟机"},//0
				{id:"1102",file:"cooker_hood_1102_CXW-268-P.pdt",width:"896",height:"860",label:"抽油烟机"},//1
				{id:"1201",file:"drainer_1201_SC8146.pdt",width:"752",height:"497",depth:"437",label:"水盆"},//2
				{id:"1301",file:"flue_1301_GP1310Z1.pdt",width:"713",height:"50",depth:"435",label:"灶台"},//3
				{id:"1305",file:"flue_1305_GP090.pdt",width:"778",height:"49",depth:"445",label:"灶台"}//4
			];
		}	
		
		//==============================================================================================
		public function CabinetController(value:InstanceClass)
		{
			if(!value)
			{
				throw new Error("WallController是一个单例类，请用静态方法getInstance来获得类的实例。");
			}
			
			initCabinetData();
		}
		
		//==============================================================================================
		static private var instance:CabinetController;
		
		static public function getInstance():CabinetController
		{
			instance ||= new CabinetController(new InstanceClass());
			return instance;
		}
		
		//==============================================================================================
	}
}

class InstanceClass{}
