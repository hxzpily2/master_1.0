package rightaway3d.house.editor2d
{
	import flash.events.MouseEvent;
	import flash.geom.Point;
	import flash.geom.Vector3D;
	import flash.utils.Dictionary;
	import flash.utils.getTimer;
	
	import away3d.core.pick.PickingColliderType;
	import away3d.events.MouseEvent3D;
	
	import rightaway3d.engine.model.ModelType;
	import rightaway3d.engine.product.ProductInfo;
	import rightaway3d.engine.product.ProductManager;
	import rightaway3d.engine.product.ProductObject;
	import rightaway3d.engine.utils.GlobalEvent;
	import rightaway3d.house.cabinet.CabinetType;
	import rightaway3d.house.lib.CabinetLib;
	import rightaway3d.house.lib.CabinetTool;
	import rightaway3d.house.utils.Geom;
	import rightaway3d.house.utils.Point3D;
	import rightaway3d.house.view2d.Product2D;
	import rightaway3d.house.view2d.Wall2D;
	import rightaway3d.house.vo.CrossWall;
	import rightaway3d.house.vo.House;
	import rightaway3d.house.vo.ObstacleType;
	import rightaway3d.house.vo.Wall;
	import rightaway3d.house.vo.WallArea;
	import rightaway3d.house.vo.WallHole;
	import rightaway3d.house.vo.WallObject;
	
	import ztc.meshbuilder.room.CabinetTable3D;
	import ztc.meshbuilder.room.CabinetTableTool;
	import ztc.meshbuilder.room.MaterialLibrary;

	public class CabinetCreator2
	{
		private var productManager:ProductManager = ProductManager.own;
		
		private var cabinetCtr:CabinetController = CabinetController.getInstance();
		
		private var _cabinetTableDefaultMaterial:String;
		
		public function get cabinetTableDefaultMaterial():String
		{
			return _cabinetTableDefaultMaterial;
		}
		
		//设置默认材质时，要重新设置当前已经创建的台面
		public function set cabinetTableDefaultMaterial(value:String):void
		{
			_cabinetTableDefaultMaterial = value;
			for each(var ct:CabinetTable3D in tableMeshs)
			{
				ct.setMaterial(value);
			}
		}
		
		private var _cabinetBodyDefaultMaterial:String;
		
		public function get cabinetBodyDefaultMaterial():String
		{
			return _cabinetBodyDefaultMaterial;
		}
		
		//设置默认材质时，要重新设置当前已经创建的柜体
		public function set cabinetBodyDefaultMaterial(value:String):void
		{
			_cabinetBodyDefaultMaterial = value;
			ProductInfo.customMaterialDict[CabinetType.BODY_PLANK] = value;
			productManager.setProductMaterial(CabinetType.BODY_PLANK,value);
		}
		
		
		private var _cabinetDoorDefaultMaterial:String;
		
		public function get cabinetDoorDefaultMaterial():String
		{
			return _cabinetDoorDefaultMaterial;
		}
		
		//设置默认材质时，要重新设置当前已经创建的柜门
		public function set cabinetDoorDefaultMaterial(value:String):void
		{
			_cabinetDoorDefaultMaterial = value;
			ProductInfo.customMaterialDict[CabinetType.DOOR_PLANK] = value;
			//productManager.setProductMaterial(CabinetType.DOOR_PLANK,value);
			this.setGroundCabinetDoorMaterial(value);
			this.setWallCabinetDoorMaterial(value);
		}
		
		/**
		 * 设置厨柜门的材质
		 * @param cabinet
		 * @param matName
		 * @param isGroup
		 * 
		 */
		/*public function setCabinetDoorMaterial(cabinet:ProductObject,matName:String,isGroup:Boolean):void
		{
			if(isGroup)
			{
				productManager.setProductMaterial(CabinetType.DOOR_PLANK,matName,cabinet.position.y);
			}
			else
			{
				cabinet.customMaterialName = matName;
			}
		}*/
		
		//设置所有地柜门及封板材质
		public function setGroundCabinetDoorMaterial(matName:String):void
		{
			setCabinetsDoorMaterial(sceneGroundCabinets,matName);
		}
		
		//设置所有吊柜门及封板材质
		public function setWallCabinetDoorMaterial(matName:String):void
		{
			setCabinetsDoorMaterial(sceneWallCabinets,matName);
		}
		
		private function setCabinetsDoorMaterial(cabs:Array,matName:String):void
		{
			for each(var po:ProductObject in cabs)
			{
				setCabinetDoorsMaterial(po,matName);
			}
		}
		
		//设置一个厨柜中所有门的材质
		public function setCabinetDoorsMaterial(po:ProductObject,matName:String):void
		{
			if(po.modelObject)
			{
				setDoorMaterial(po,matName);
			}
			else
			{
				if(po.subProductObjects)setDoorsMaterial(po.subProductObjects,matName);
				if(po.dynamicSubProductObjects)setDoorsMaterial(po.dynamicSubProductObjects,matName);
			}
		}
		
		private function setDoorsMaterial(pos:Vector.<ProductObject>,matName:String):void
		{
			for each(var po:ProductObject in pos)
			{
				setCabinetDoorsMaterial(po,matName);
			}
		}
		
		//设置当前门的材质
		public function setDoorMaterial(po:ProductObject,matName:String):void
		{
			if(po.productInfo.type==CabinetType.DOOR_PLANK)
			{
				po.customMaterialName = matName;
			}
		}
		
		/*
		自动创建规则
		总体规则：统一性，对称性，大尺寸（900）优先
		细则：
		1,柜与柜之间不留间隙
		2,电器中指定电烤箱时，电烤箱柜放置于灶台位置，与灶台保持中心对齐
		3,一般情况下，灶台左右各放置一个300的拉篮柜
		4,灶台下如果是电烤箱，必须左右都放置拉篮柜
		5,灶下如果不放置电器则默认放置800或900碗盘拉篮柜
		6,灶台下放置双开门灶台柜时，如果空间不够，可以只放置一个或不放置拉篮柜
		7,抽油烟机与灶台保持中心对齐，与左右吊柜最小间距30mm
		8,水盆和灶台放置于同一面墙时，水盆和灶台之间要尽可能的远
		9,默认有一个抽屉柜，空间允许情况下放置与水盆柜同规格的二平分抽屉柜，
		否则放置小小大抽屉柜，优先放置600，其次450，如果不够450，则不放置抽屉柜。
		10,消毒柜：指定的电器之中有消毒柜时，放置此柜，一般位于水盆柜的左边或右边
		11,转角柜至邻墙间距至少100（600-（900-400）），转角柜门外面与相邻墙地柜侧板的最小间距为50
		12,柜体拐角处封板默认为50mm，柜体与墙之间距离不得小于30mm
		13,上翻门吊柜：默认放一个
		14,转角吊柜：转角柜至邻墙间距紧贴，转角柜门外面与相邻墙吊柜侧板的最小间距为50
		15,拐角挡板，柜腿挡板
		16,左开门右开门
		
		17，开门方向怎么定?
		18，缝隙挡板规格位置？
		19，柜腿挡板规格位置？
		
		要先解决的问题：
		1，台面挡门(ok)
		2，缝隙问题
		3，水盆灶台同墙处理（ok）
		4，可指定电器设备型号（还差电器）
		*/
		/*
		自动创建算法
		设置房间尺寸
		设置门窗
		选择墙体，设置放置厨柜的区域范围
		放置水盆灶台定位标志
		设置每个选择区域的首尾标志：首或尾是否有拐角柜，首或尾的障碍物类型
		根据区域间的衔接情况，及中间有门分割情况，计算独立分区
		对每个区域根据根据障碍物进行分段
		对每个分段设置首尾标志：首或尾是否有拐角柜，首或尾的障碍物类型
		对分段的首或尾的障碍物类型为墙洞的，作缩进处理
		生成地柜组合
		对分段首或尾没有障碍物的（NULL)的，要调整分段尺寸，使当前端的台面出沿30mm
		根据地柜组合尺寸及分段首尾障碍物类型，计算地柜组合位置
		调整水盆灶台及烟机位置
		加载地柜及水盆灶台烟机
		计算台面数据及水盆挖洞位置，创建台面
		
		根据烟机窗户及其它障碍物，对吊柜区域进行分段
		对每个分段设置首尾标志：首或尾是否有拐角柜，首或尾的障碍物类型
		对分段的首或尾的障碍物类型为墙洞的，作缩进处理
		生成吊柜组合
		根据吊柜组合尺寸及分段首尾障碍物类型，计算吊柜组合位置
		加载吊柜
		
		布置地柜前，要对墙体按障碍物及门进行分段
		布置吊柜前，要对墙体按障碍物、门及窗进行分段
		创建台面前，要对地柜进行区域划分
		地柜
		根据整体布局指定拐角柜
		根据水盆灶台定位标志位置，初步指定水盆灶台柜位置
		匹配水盆灶台的柜体型号及相关电器柜与拉篮柜
		根据墙面可用长度，初步指定厨柜列表
		匹配合适型号的抽屉柜
		整体位置调整，合并缝隙
		根据多余缝隙，个别调整厨柜型号
		创建台面
		
		吊柜
		根据整体布局指定拐角柜
		根据灶台位置确定烟机位置
		放置上翻门吊柜
		放置其它厨柜
		*/
		
		private var drainerData:Object;
		private var flueData:Object;
		private var cookerHoodData:Object;
		private var sterilizerData:Object;
		private var ovenData:Object;

		private var flueFlag:Product2D;
		private var drainerFlag:Product2D;

		/**
		 * 自动创建厨柜
		 * @param drainer：水盆数据
		 * @param flue：灶台数据
		 * @param cookerHood：烟机数据
		 * @param sterilizer：消毒柜数据
		 * @param oven：烤箱数据
		 * 
		 */
		public function autoCreateCabinet(drainer:Object,flue:Object,cookerHood:Object,sterilizer:Object=null,oven:Object=null):void
		{
			flueFlag = cabinetCtr.flueFlag;
			drainerFlag = cabinetCtr.drainerFlag;
			
			//trace("0");
			if(!flueFlag || !drainerFlag)
			{
				throw new Error("请放置"+(!drainerFlag?"水盆":"灶台")+"到已选择的区域上");
				return;
			}
			//trace("1");
			//if(!flueFlag.wall || !drainerFlag.wall)return;
			//trace("2");
			
			var generalWall:Wall2D;//一般墙体，既没有灶台也没有水盆关联
			var generalWall:Wall2D;//一般墙体，既没有灶台也没有水盆关联
			var generalCrossWall:CrossWall;
			var walls:Dictionary = cabinetCtr.currRoom2d.walls;
			
			for(var w:Wall2D in walls)
			{
				//if(w.selected)//从厨房的已选中墙体中，找出一般墙体，用来创建无灶台无水盆的厨柜组合
				if(w.vo.selectorArea)//从厨房的已选中墙体中，找出一般墙体，用来创建无灶台无水盆的厨柜组合
				{
					if(w!=flueFlag.wall && w!=drainerFlag.wall)
					{
						trace("只允许有一个一般墙体");
						if(generalWall)
						{
							throw new Error("只能有一面墙不放置水盆和灶台");
							return;//只允许有一个一般墙体
						}
						
						generalWall = w;
						generalCrossWall = walls[w];
					}
				}
			}
			
			drainerData = drainer;
			flueData = flue;
			cookerHoodData = cookerHood;
			sterilizerData = sterilizer;
			ovenData = oven;
			
			//即使水盆或灶台柜所在的墙体被用户取消了选择，而不是移动水盆和灶台标志，仍然将所在墙体设为选中状态，并在其上自动创建厨柜
			/*flueFlag.wall.selected = true;
			flueFlag.updateView();
			
			drainerFlag.wall.selected = true;
			drainerFlag.updateView();*/
			
			var flueCrossWall:CrossWall = walls[flueFlag.wall];
			var drainerCrossWall:CrossWall = walls[drainerFlag.wall];
			
			if(!generalCrossWall)//没有一般墙体
			{
				if(flueCrossWall == drainerCrossWall)//水盆和灶台放置于同一面墙体
				{
					trace("水盆和灶台放置于同一面墙体");
					setCameraPanAngle(flueCrossWall.wall);
					//_autoCreateCabinet2(flueCrossWall,flueFlag,false,drainerFlag);
					_autoCreateCabinet([[drainerCrossWall]]);
				}
				else//水盆和灶台放置于不同墙体
				{
					if(drainerCrossWall.endCrossWall==flueCrossWall && flueCrossWall.headCrossWall==drainerCrossWall)
					{
						trace("水盆-->灶台");
						setCameraPanAngle(drainerCrossWall.wall,flueCrossWall.wall);
						//_autoCreateCabinet2(drainerCrossWall,null,false,drainerFlag,false,true);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,null,false,false,600);
						_autoCreateCabinet([[drainerCrossWall,flueCrossWall]]);
					}
					else if(flueCrossWall.endCrossWall==drainerCrossWall && drainerCrossWall.headCrossWall==flueCrossWall)
					{
						trace("灶台-->水盆");
						setCameraPanAngle(drainerCrossWall.wall,flueCrossWall.wall);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,null,false,true);
						//_autoCreateCabinet2(drainerCrossWall,null,false,drainerFlag,false,false,600);
						_autoCreateCabinet([[flueCrossWall,drainerCrossWall]]);
					}
					else//两个墙面不相交
					{
						trace("两个墙面不相交");
						setCameraPanAngle(flueCrossWall.wall);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,null);
						//_autoCreateCabinet2(drainerCrossWall,null,false,drainerFlag);
						_autoCreateCabinet([[flueCrossWall],[drainerCrossWall]]);
					}
				}
			}
			else
			{
				trace("一般墙体");
				if(flueCrossWall == drainerCrossWall)//水盆和灶台放置于同一面墙体
				{
					trace("水盆和灶台放置于同一面墙体");
					if(generalCrossWall.headCrossWall==drainerCrossWall && drainerCrossWall.endCrossWall==generalCrossWall)
					{
						trace("水盆,灶台-->一般墙体");
						setCameraPanAngle(generalCrossWall.wall,flueCrossWall.wall);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,drainerFlag,false,true);
						//_autoCreateCabinet2(generalCrossWall,null,false,null,false,false,600);
						_autoCreateCabinet([[drainerCrossWall,generalCrossWall]]);
					}
					else if(generalCrossWall.endCrossWall==drainerCrossWall && drainerCrossWall.headCrossWall==generalCrossWall)
					{
						trace("一般墙体-->水盆,灶台");
						setCameraPanAngle(generalCrossWall.wall,flueCrossWall.wall);
						//_autoCreateCabinet2(generalCrossWall,null,false,null,false,true);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,drainerFlag,false,false,600);
						_autoCreateCabinet([[generalCrossWall,drainerCrossWall]]);
					}
					else//两个墙面不相交
					{
						trace("两个墙面不相交");
						setCameraPanAngle(flueCrossWall.wall);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,drainerFlag);
						//_autoCreateCabinet2(generalCrossWall);
						_autoCreateCabinet([[drainerCrossWall],[generalCrossWall]]);
					}
				}
				else//水盆和灶台放置于不同墙体
				{
					if(drainerCrossWall.endCrossWall==flueCrossWall && flueCrossWall.endCrossWall==generalCrossWall)
					{
						trace("水盆-->灶台-->一般墙体");
						setCameraPanAngle(flueCrossWall.wall);
						//_autoCreateCabinet2(drainerCrossWall,null,false,drainerFlag,false,true);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,null,false,true,600);
						//_autoCreateCabinet2(generalCrossWall,null,false,null,false,false,600);
						_autoCreateCabinet([[drainerCrossWall,flueCrossWall,generalCrossWall]]);
					}
					else if(flueCrossWall.endCrossWall==drainerCrossWall && drainerCrossWall.endCrossWall==generalCrossWall)
					{
						trace("灶台-->水盆-->一般墙体");
						setCameraPanAngle(drainerCrossWall.wall);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,null,false,true);
						//_autoCreateCabinet2(drainerCrossWall,null,false,drainerFlag,false,true,600);
						//_autoCreateCabinet2(generalCrossWall,null,false,null,false,false,600);
						_autoCreateCabinet([[flueCrossWall,drainerCrossWall,generalCrossWall]]);
					}
					else if(drainerCrossWall.endCrossWall==generalCrossWall && generalCrossWall.endCrossWall==flueCrossWall)
					{
						trace("水盆-->一般墙体-->灶台");
						setCameraPanAngle(generalCrossWall.wall);
						//_autoCreateCabinet2(drainerCrossWall,null,false,drainerFlag,false,true);
						//_autoCreateCabinet2(generalCrossWall,null,false,null,false,true,600);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,null,false,false,600);
						_autoCreateCabinet([[drainerCrossWall,generalCrossWall,flueCrossWall]]);
					}
					else if(flueCrossWall.endCrossWall==generalCrossWall && generalCrossWall.endCrossWall==drainerCrossWall)
					{
						trace("灶台-->一般墙体-->水盆");
						setCameraPanAngle(generalCrossWall.wall);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,null,false,true);
						//_autoCreateCabinet2(generalCrossWall,null,false,null,false,true,600);
						//_autoCreateCabinet2(drainerCrossWall,null,false,drainerFlag,false,false,600);
						_autoCreateCabinet([[flueCrossWall,generalCrossWall,drainerCrossWall]]);
					}
					else if(generalCrossWall.endCrossWall==drainerCrossWall && drainerCrossWall.endCrossWall==flueCrossWall)
					{
						trace("一般墙体-->水盆-->灶台");
						setCameraPanAngle(drainerCrossWall.wall);
						//_autoCreateCabinet2(generalCrossWall,null,false,null,false,true);
						//_autoCreateCabinet2(drainerCrossWall,null,false,drainerFlag,false,true,600);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,null,false,false,600);
						_autoCreateCabinet([[generalCrossWall,drainerCrossWall,flueCrossWall]]);
					}
					else if(generalCrossWall.endCrossWall==flueCrossWall && flueCrossWall.endCrossWall==drainerCrossWall)
					{
						trace("一般墙体-->灶台-->水盆");
						setCameraPanAngle(flueCrossWall.wall);
						//_autoCreateCabinet2(generalCrossWall,null,false,null,false,true);
						//_autoCreateCabinet2(flueCrossWall,flueFlag,false,null,false,true,600);
						//_autoCreateCabinet2(drainerCrossWall,null,false,drainerFlag,false,false,600);
						_autoCreateCabinet([[generalCrossWall,flueCrossWall,drainerCrossWall]]);
					}
					else
					{
						trace("这是什么情况");
					}
				}
			}
		}
		
		private var tableMeshs:Vector.<CabinetTable3D> = new Vector.<CabinetTable3D>();
		
		//更新台面位置
		public function updateTableMeshsPos(dx:Number,dz:Number):void
		{
			for each(var ct:CabinetTable3D in tableMeshs)
			{
				ct.x = -dx;
				ct.z = -dz;
				trace("updateTableMeshsPos:"+ct.x,ct.z);
			}
			if(flueProduct)
			{
				flueProduct.container3d.x = flueProduct.position.x - dx;
				flueProduct.container3d.z = flueProduct.position.z - dz;
			}
			if(drainerProduct)
			{
				drainerProduct.container3d.x = drainerProduct.position.x - dx;
				drainerProduct.container3d.z = drainerProduct.position.z - dz;
			}
			/*var len:int = tableMeshs.length;
			for(var i:int=0;i<len;i++)
			{
			var m:Mesh = tableMeshs[i];
			m.x = -dx;
			m.z = -dz;
			}*/
		}
		
		//切换台面的显示状态
		public function switchCabinetTableVisible():void
		{
			for each(var ct:CabinetTable3D in tableMeshs)
			{
				ct.visible = !ct.visible;
				trace("ct.visible:"+ct.visible);
			}
			if(flueProduct)
			{
				flueProduct.container3d.visible = ct.visible;
			}
			if(drainerProduct)
			{
				drainerProduct.container3d.visible = ct.visible;
			}
			/*var len:int = tableMeshs.length;
			for(var i:int=0;i<len;i++)
			{
			var m:Mesh = tableMeshs[i];
			m.visible = !m.visible;
			}*/
		}
		
		//添加台面到三维显示
		private function addTableMeshs():void
		{
			for each(var ct:CabinetTable3D in tableMeshs)
			{
				cabinetCtr.engineManager.addRootChild(ct);
			}
			/*var len:int = tableMeshs.length;
			for(var i:int=0;i<len;i++)
			{
			var m:Mesh = tableMeshs[i];
			engineManager.addRootChild(m);
			}*/
		}
		
		public function getCabinetList():String
		{
			/*getCabinetDoorData();
			getCabinetBodyData();
			getTableData();
			getCabinetHandleData();*/
			var subtotal:Object = {};
			var s:String = "{";
			s += "\"gttm\":{";
			s += "\"list\":["+getProductsData(CabinetType.BODY,subtotal);
			s += getCabinetDoorData(subtotal) + ",";
			s += getTableData(subtotal)+"],";
			s += "\"body\":"+getNum(subtotal,CabinetType.BODY)+",";
			s += "\"door\":"+getNum(subtotal,CabinetType.DOOR_PLANK)+",";
			s += "\"table\":"+getNum(subtotal,CabinetType.TABLE)+"},";
			s += "\"wjdq\":{";
			s += "\"list\":["+getDeviceData(subtotal)+"],";
			s += "\"wjxj\":"+getWujinSubtotal(subtotal)+",";
			s += "\"dqxj\":"+getDeviceSubtotal(subtotal);
			s += "},";
			s += "\"total\":"+getTotal(subtotal);
			s += "}";
			return s;
		}
		
		private function getTotal(subtotal:Object):Number
		{
			var n:Number = 0;
			for each(var t:Number in subtotal)
			{
				n += t;
			}
			return n;
		}
		
		//电器配件小计柜门板:
		private function getDeviceSubtotal(subtotal:Object):Number
		{
			var n:Number = 0;
			n += getNum(subtotal,CabinetType.DRAINER);
			n += getNum(subtotal,CabinetType.FLUE);
			n += getNum(subtotal,CabinetType.HOOD);
			n += getNum(subtotal,CabinetType.OVEN);
			n += getNum(subtotal,CabinetType.STERILIZER);
			return n;
		}
		
		//五金配件小计
		private function getWujinSubtotal(subtotal:Object):Number
		{
			var n:Number = 0;
			n += getNum(subtotal,CabinetType.HANDLE);
			n += getNum(subtotal,CabinetType.LEG);
			n += getNum(subtotal,CabinetType.DRAWER);
			n += getNum(subtotal,CabinetType.BASKET);
			return n;
		}
		
		private function getNum(subtotal:Object,type:String):Number
		{
			return subtotal[type]?subtotal[type]:0;
		}
		
		private function getDeviceData(subtotal:Object):String
		{
			var s:String = "";
			s += getProductsData(CabinetType.DRAINER,subtotal);
			s += getProductsData(CabinetType.FLUE,subtotal);
			s += getProductsData(CabinetType.HOOD,subtotal);
			s += getProductsData(CabinetType.DRAWER,subtotal);
			s += getProductsData(CabinetType.BASKET,subtotal);
			s += getProductsData(CabinetType.OVEN,subtotal);
			s += getProductsData(CabinetType.STERILIZER,subtotal);
			s += getProductsData(CabinetType.HANDLE,subtotal);
			s += getProductsData(CabinetType.LEG,subtotal);
			s = s.slice(0,-1);
			return s;
		}
		
		public function getCabinetDoorData(subtotal:Object):String
		{
			var infos:Array = productManager.getProductsByType(CabinetType.DOOR_PLANK);
			var len:int = infos.length;
			var n:Number = 0;
			for(var i:int=0;i<len;i++)
			{
				var info:ProductInfo = infos[i];
				var plen:int = info.getProductObjects().length;
				if(plen>0)
				{
					var d:Vector3D = info.dimensions;
					trace(info.name+":"+d+" num:"+plen);
					
					n += d.x * d.y * plen;
				}
				//if(plen>0)trace("部件名称："+info.name+" 规格："+info.specifications+" 单价："+info.price+" 数量："+plen+" 金额："+info.price*plen+" 备注："+info.memo);
			}
			
			var name:String = this._cabinetDoorDefaultMaterial;
			var price:Number = MaterialLibrary.instance.getMaterialPrice(name);
			var t:int = Math.ceil(n / 1000);
			n = t/1000; //单位转换为平米,精确到小数点后3位数
			
			//trace("部件名称："+"门板"+" 规格："+name+" 单价："+price+" 数量："+n+" 金额："+price*n+" 备注："+"");
			var total:Number = price*n;
			var c:int = Math.ceil(total*100);
			total = c/100;//保留两位小数
			subtotal[CabinetType.DOOR_PLANK] = total;
			
			return toOrderJson("门板","平方米",price,n,total,name);
		}
		
		/*public function getCabinetBodyData():void
		{
			var infos:Array = productManager.getProductsByType(CabinetType.BODY);
			var len:int = infos.length;
			for(var i:int=0;i<len;i++)
			{
				var info:ProductInfo = infos[i];
				var plen:int = info.getProductObjects().length;
				if(plen>0)trace("部件名称："+info.name+" 规格："+info.specifications+" 单价："+info.price+" 数量："+plen+" 金额："+info.price*plen+" 备注："+info.memo);
			}
		}*/
		
		/*public function getCabinetHandleData():void
		{
			var infos:Array = productManager.getProductsByType(CabinetType.HANDLE);
			var len:int = infos.length;
			for(var i:int=0;i<len;i++)
			{
				var info:ProductInfo = infos[i];
				var plen:int = info.getProductObjects().length;
				if(plen>0)trace("部件名称："+info.name+" 规格："+info.specifications+" 单价："+info.price+" 数量："+plen+" 金额："+info.price*plen+" 备注："+info.memo);
			}
		}*/
		
		private function getProductsData(type:String,subtotal:Object):String
		{
			var s:String = "";
			var infos:Array = productManager.getProductsByType(type);
			var len:int = infos.length;
			for(var i:int=0;i<len;i++)
			{
				var info:ProductInfo = infos[i];
				var plen:int = info.getProductObjects().length;
				if(plen>0)
				{
					var total:Number = info.price*plen;
					var c:int = Math.ceil(total*100);
					total = c/100;//保留两位小数
					
					if(subtotal[type])
					{
						subtotal[type] += total;
					}
					else
					{
						subtotal[type] = total;
					}
					s += toOrderJson(info.name,info.specifications,info.price,plen,total,info.memo) + ",";
					//trace("部件名称："+info.name+" 规格："+info.specifications+" 单价："+info.price+" 数量："+plen+" 金额："+info.price*plen+" 备注："+info.memo);
				}
			}
			return s;
		}
		
		public function getTableData(subtotal:Object):String
		{
			var name:String = this._cabinetTableDefaultMaterial;
			var n:Number = 0;
			for each(var ct:CabinetTable3D in tableMeshs)
			{
				n += ct.getArea();
			}
			var price:Number = MaterialLibrary.instance.getMaterialPrice(name);
			n /= 0.6;//将面积转换为长度（延米)
			
			var total:Number = price*n;
			var c:int = Math.ceil(total*100);
			total = c/100;//保留两位小数
			
			subtotal[CabinetType.TABLE] = total;
			return toOrderJson("台面","米",price,n,total,name);
		}
		
		//[name:部件名称，guige:规格，price:单价，num：数量，subtotal：金额，other；备注]
		private function toOrderJson(name:String,guige:String,price:Number,num:Number,subtotal:Number,other:String):String
		{
			var s:String = "{";
			s += "\"name\":\""+name+"\",";
			s += "\"guige\":\""+guige+"\",";
			s += "\"price\":"+price+",";
			s += "\"num\":"+num+",";
			s += "\"subtotal\":"+subtotal+",";
			s += "\"other\":\""+other+"\"";
			s += "}";
			trace("部件名称："+name+" 规格："+guige+" 单价："+price+" 数量："+num+" 金额："+subtotal+" 备注："+other);
			
			return s;
		}
		
		//清除台面
		private function removeTableMeshs():void
		{
			while(tableMeshs.length>0)
			{
				var ct:CabinetTable3D = tableMeshs.pop();
				ct.removeEventListener(MouseEvent3D.MOUSE_DOWN,onMouseDown);
				ct.removeEventListener(MouseEvent3D.MOUSE_UP,onMouseUp);
				ct.disposeWithAnimatorAndChildren();
			}
			/*var len:int = tableMeshs.length;
			for(var i:int=0;i<len;i++)
			{
			var m:Mesh = tableMeshs[i];
			engineManager.removeRootChild(m);
			m.dispose();
			}
			tableMeshs.length = 0;*/
		}
		
		public function clear():void
		{
			removeTableMeshs();
			if(flueProduct)
			{
				flueProduct.dispose();
				flueProduct = null;
			}
			if(drainerProduct)
			{
				drainerProduct.dispose();
				drainerProduct = null;
			}
			for each(var po:ProductObject in plateDict)
			{
				po.dispose();
			}
			this.sceneGroundCabinets.length = 0;
			this.sceneWallCabinets.length = 0;
		}
		
		//创建台面模型
		/*private function createTableMesh(points:Array,holePoint:Point,holes:Array=null,n:int=100,r:int=1):void
		{
			//var n:int = 2;
			if(!holes)
			{
				var p:Point = holePoint;
				var p1:Point = new Point(p.x+n,p.y+n);
				var p2:Point = new Point(p.x-n,p.y+n);
				var p3:Point = new Point(p.x-n,p.y-n);
				var p4:Point = new Point(p.x+n,p.y-n);
				holes = [p1,p2,p3,p4];
			}
			
			_createTableMesh(points,holes,r);
		}*/
		
		private function createTableMesh(dangshui:Array,points:Array,holes:Array=null,r:int=1,segment:uint=8,height:Number=40
										  /*,textureURL:String="",normalURL:String="",
										  color:uint=0xDDDDDD,ambient:Number=0.8,
										  specular:Number=0.3,gloss:Number=50*/
		):void
		{
			var ct:CabinetTable3D = CabinetTableTool.createCabinetTable(dangshui,points,holes,r,segment,height);//,textureURL,normalURL,color,ambient,specular,gloss);
			//ct.material.lightPicker = engineManager.engine3d.lightPicker;
			
			//RenderUtils.setMaterial(ct,RenderUtils.getDefaultMaterial("table"));
			ct.setMaterial(this.cabinetTableDefaultMaterial);
			
			ct.y = 800;
			//ct.visible = false;
			//trace("tableMesh:"+m);
			tableMeshs.push(ct);
			
			ct.pickingCollider = PickingColliderType.AS3_FIRST_ENCOUNTERED;
			ct.mouseEnabled = ct.mouseChildren = true;
			
			ct.addEventListener(MouseEvent3D.MOUSE_DOWN,onMouseDown);
			ct.addEventListener(MouseEvent3D.MOUSE_UP,onMouseUp);
		}
		
		private var isMouseDown:Boolean;
		private var isMouseMove:Boolean;
		
		private function onMouseDown(e:MouseEvent3D):void
		{
			isMouseDown = true;
			isMouseMove = false;
			GlobalEvent.event.dispatchCabinetTableMouseDownEvent(tableMeshs);
			cabinetCtr.scene.addEventListener(MouseEvent.MOUSE_MOVE,onMouseMove);
		}
		
		private function onMouseMove(e:MouseEvent):void
		{
			isMouseMove = true;
		}
		
		private function onMouseUp(e:MouseEvent3D):void
		{
			cabinetCtr.scene.stage.removeEventListener(MouseEvent.MOUSE_MOVE,onMouseMove);
			
			if(!isMouseDown || isMouseMove)return;//如果鼠标不在此模型上按下，或者发生了移动，则不执行此后动作
			isMouseDown = false;
			
			var n:int = getTimer();
			//trace(n-lastTime);
			if(n-lastTime<1000)
			{
				GlobalEvent.event.dispatchCabinetTableMouseUpEvent(tableMeshs);
				trace("tableMouseUpEvent:"+(n-lastTime));
				lastTime = 0;
			}
			else
			{
				lastTime = n;
			}
		}
		
		public function getCabinetTableData():String
		{
			var s:String = "{";
			s += "\"tables\":[";
			var len:int = tableMeshs.length;
			for(var i:int=0;i<len;i++)
			{
				var ct:CabinetTable3D = tableMeshs[i];
				s += ct.toJsonString() + (i<len-1?",":"");
			}
			s += "]";
			if(drainerProduct)s += getCookerProductData("drainerProduct",drainerProduct);
			if(flueProduct)s += getCookerProductData("flueProduct",flueProduct);
			s += "}";
			return s;
		}
		
		private function getCookerProductData(name:String,po:ProductObject):String
		{
			var s:String = ",\""+name+"\":" + po.toJsonString();
			return s;
		}
		
		public function createCabinetTable(cabinetTable:Object):void
		{
			//removeTableMeshs();
			
			var tables:Array = cabinetTable.tables;
			
			for each(var ctData:Object in tables)
			{
				var border:Array = getPointsArray(ctData.border);
				var dangshui:Array = getPointsArray(ctData.dangshui);
				if(ctData.hole)var hole:Array = getPointsArray(ctData.hole);
				var radius:Number = ctData.radius;
				var segment:Number = ctData.segment;
				var height:Number = ctData.height;
				var materialName:String = ctData.materialName;
				this.cabinetTableDefaultMaterial = materialName;
				/*var textureURL:String = ctData.textureURL;
				var normalURL:String = ctData.normalURL;
				var color:Number = ctData.color;
				var ambient:Number = ctData.ambient;
				var specular:Number = ctData.specular;
				var gloss:Number = ctData.gloss;*/
				
				createTableMesh(dangshui,border,hole,radius,segment,height);//,textureURL,normalURL,color,ambient,specular,gloss);
			}
			
			addTableMeshs();
			
			if(cabinetTable.drainerProduct!=undefined)
			{
				drainerProduct = productManager.parseProductObject2(cabinetTable.drainerProduct);
				//drainerProduct.container3d.visible = false;
			}
			
			if(cabinetTable.flueProduct!=undefined)
			{
				flueProduct = productManager.parseProductObject2(cabinetTable.flueProduct);
				//flueProduct.container3d.visible = false;
			}
		}
		
		private function getPointsArray(a:Array):Array
		{
			var ps:Array = [];
			var len:int = a.length;
			for(var i:int=0;i<len;i++)
			{
				var o:Object = a[i];
				var p:Point = new Point(o.x,o.y);
				ps.push(p);
			}
			return ps;
		}
		
		//
		/**
		 * 计算台面数据
		 * @param tables：当前厨房有1个或2个独立的台面，
		 * 1个台面时，台面依靠1～3个相邻墙面创建而成，
		 * 2个独立台面时，每个台面依靠1个不与其它墙面相邻的墙面创建而成
		 * @param holes：与独立台面上每个墙面对应的洞口标志
		 * @param depth：台面深度
		 * @param holeWidth：洞口默认宽度
		 * @param holeDepth：洞口默认深度
		 * 
		 */
		private function _autoCreateCabinet(tables:Array,depth:int=600,holeWidth:int=700,holeDepth:int=400):void
		{
			var tss:Array = resetTablesArea(tables);
			
			createGroundCabinetArea(tss);
			
			createCabinetTable3(tss);
			
			setWallCabinetArea(tss);
			
			createWallCabinetArea(tss);
			
			cabinetCtr.scene.render();
		}
		
		/**
		 * 设置吊柜
		 * 
		 */
		private function setWallCabinetArea(tabless:Array):void
		{
			var tlen:int = tabless.length;
			for(var i:int=0;i<tlen;i++)
			{
				var tables:Array = tabless[i];//每个独立台面分区
				var tlen2:int = tables.length;
				for(var j:int=0;j<tlen2;j++)//组成台面的每个墙面
				{
					var tableData:Object = tables[j];
					var cw:CrossWall = tableData.cw;
					var x0:Number = tableData.x0;
					var x1:Number = tableData.x1;
					var headCorner:Boolean = tableData.headCorner;
					var endCorner:Boolean = tableData.endCorner;
					var headType:String = tableData.headType;
					var endType:String = tableData.endType;
					
					setWallObjectArea(tableData,cw,x0,x1,headCorner,endCorner,headType,endType);
				}
			}
		}
		
		/**
		 * 根据障碍物来调整台面分区中的厨柜区域的分段
		 * @param tabless
		 * 
		 */
		private function createGroundCabinetArea(tabless:Array):void
		{
			var tlen:int = tabless.length;
			for(var i:int=0;i<tlen;i++)
			{
				var tables:Array = tabless[i];//每个独立台面分区
				var tlen2:int = tables.length;
				for(var j:int=0;j<tlen2;j++)//组成台面的每个墙面
				{
					var tableData:Object = tables[j];
					var cw:CrossWall = tableData.cw;
					var groundObjects:Array = tableData.groundObjects;//墙面被障碍分隔成的区间
					var glen:int = groundObjects.length;
					for(var k:int=0;k<glen;k++)
					{
						var o:Object = groundObjects[k];
						var x0:Number = o.x0;
						var x1:Number = o.x1;
						var d:* = o.drainerFlag;
						var f:* = o.flueFlag;
						var hc:Boolean = o.headCorner;
						var ec:Boolean = o.endCorner;
						var ht:String = o.headType;
						var et:String = o.endType;
						
						var cs:Array = CabinetTool.tool.getGroundCabinetGroup(cw,x0,x1,d,f,this.sterilizerData,this.ovenData,hc,ec);
						//o.cabinets = cs;
						
						var aw:Number = x1-x0;//当前分段有效长度
						var gw:int = getGroupWidth(cs);//当前分段中所放置的厨柜组长度
						
						var startOffset:Number = getStartOffset(cw,x0,x1,ht,et,hc,ec,aw,gw);
						
						loadGroundCabinet(x0,x1,startOffset,cs,cw,d,f,ht,et);
						
						//调整台面在门洞两边的厨柜上的出沿尺寸
						if(ht==ObstacleType.HOLE)//分区从门洞开始
						{
							tableData.x0 = x0 + startOffset - 30;//从厨柜的左则伸出30mm
						}
						if(et==ObstacleType.HOLE)//分区到门洞结束
						{
							tableData.x1 = x0 + startOffset + gw + 30;//从厨柜的右则伸出30mm
						}
					}
				}
			}
		}
		
		private var plateDict:Dictionary = new Dictionary();
		
		/**
		 * 创建厨柜封板
		 * 
		 */
		private function createCabinetPlate(cw:CrossWall,width:int,height:int,depth:int,xPos:Number,yPos:Number,zPos:Number,ctype:String):ProductObject
		{
			var mtype:String = ModelType.BOX_C;
			var name:String = "cabinet_baffle";
			var po:ProductObject = ProductManager.own.createCustomizeProduct(mtype,name,width,height,depth,0xffffff,false);
			po.productInfo.name = name;
			po.productInfo.type = ctype;
			
			if(ctype==CabinetType.DOOR_PLANK)po.customMaterialName = _cabinetDoorDefaultMaterial;
			else
				po.customMaterialName = "柜脚挡板";
			
			var n:int = cw.wall.width*0.5+zPos;
			zPos = cw.isHead?-n:n;
			var p:Point = new Point(xPos,zPos);
			cw.wall.localToGlobal2(p,p);
			
			po.position.x = p.x;
			po.position.y = yPos;
			po.position.z = p.y;
			
			var a:Number = 360 - cw.wall.angles;
			po.rotation.y = po.container3d.rotationY = cw.isHead ? a+180 : a;
			
			var wo:WallObject = new WallObject();
			wo.object = po;
			wo.width = width;
			wo.height = height;
			wo.depth = depth;
			wo.x = xPos;
			wo.y = yPos;
			wo.z = zPos;
			
			po.objectInfo = wo;
			
			plateDict[po] = po;
			
			return po;
		}
		
		/**
		 * 创建吊柜
		 * 
		 */
		private function createWallCabinetArea(tabless:Array):void
		{
			var tlen:int = tabless.length;
			for(var i:int=0;i<tlen;i++)
			{
				var tables:Array = tabless[i];//每个独立台面分区
				var tlen2:int = tables.length;
				for(var j:int=0;j<tlen2;j++)//组成台面的每个墙面
				{
					var tableData:Object = tables[j];
					var cw:CrossWall = tableData.cw;
					var wallObjects:Array = tableData.wallObjects;//墙面被障碍分隔成的区间
					var glen:int = wallObjects.length;
					
					for(var k:int=0;k<glen;k++)
					{
						var o:Object = wallObjects[k];
						var x0:Number = o.x0;
						var x1:Number = o.x1;
						var hc:Boolean = o.headCorner;
						var ec:Boolean = o.endCorner;
						var ht:String = o.headType;
						var et:String = o.endType;
						
						var cs:Array = CabinetTool.tool.getWallCabinetGroup(cw,x0,x1,hc,ec);
						//o.cabinets = cs;
						
						var aw:Number = x1-x0;
						var gw:int = getGroupWidth(cs);
						
						var startOffset:Number = getStartOffset2(cw,x0,x1,ht,et,hc,ec,aw,gw);
						
						loadWallCabinet(x0+startOffset,cs,cw);
					}
				}
			}
		}
		
		private function loadWallCabinet(start:Number,list:Array,cw:CrossWall):void
		{
			var len:int = list.length;
			
			for(var i:int=0;i<len;i++)
			{
				var xml:XML = list[i];
				var id:String = xml.id;
				var width:int = xml.width;
				start += width;
				
				var type:String = xml.flag;
				if(i==0 && type=="corner")
				{
					var po:ProductObject = this.createCabinetPlate(cw,400,720,16,start-400,1540,331,CabinetType.DOOR_PLANK);//在吊柜拐角柜左侧创建封板
					sceneWallCabinets.push(po);
					var door:XML = CabinetLib.lib.getDoor("wall_cabinet","left",800);//在吊柜拐角柜右侧放置左开门
				}
				else if(i==len-1 && type=="corner")
				{
					po = this.createCabinetPlate(cw,400,720,16,start,1540,331,CabinetType.DOOR_PLANK);//在吊柜拐角柜右侧创建封板
					sceneWallCabinets.push(po);
					door = CabinetLib.lib.getDoor("wall_cabinet","right",800);//在吊柜拐角柜左侧放置右开门
				}
				else if(xml.door)
				{
					door= xml.door[0];
				}
				else
				{
					door = null;
				}
				
				xml = CabinetLib.lib.getCabinetData(id);
				var p:Product2D = this.createWallCabinet(xml,cw,start,door);
				sceneWallCabinets.push(p.vo);
			}
		}
		
		private function loadGroundCabinet(x0:Number,x1:Number,offset:int,list:Array,cw:CrossWall,drainer:Product2D,flue:Product2D,ht:String,et:String):void
		{
			var start:Number = x0 + offset;
			var len:int = list.length;
			for(var i:int=0;i<len;i++)
			{
				var xml:XML = list[i];
				var id:String = xml.id;
				var type:String = xml.flag;
				var width:int = xml.width;
				start += width*0.5;
				
				var elec:XML = xml.item?xml.item[0]:null;//电器
				
				if(drainer && type=="drainer")
				{
					setProductPos(drainer,cw,start);
					
					o = drainerData?drainerData:getCabinetData(cookerProducts,2);
					drainerProduct = addCookerProduct(o,cw,drainer.vo.objectInfo);
					drainerProduct.isLock = true;
				}
				
				if(flue && (type=="drawer" || type=="oven"))
				{
					setProductPos(flue,cw,start);
					
					var o:Object = cookerHoodData?cookerHoodData:getCabinetData(cookerProducts,1);//抽油烟机
					hoodProduct = createWallCabinet(o,cw,start+o.width*0.5);
					hoodProduct.vo.isLock = true;
					
					o = flueData?flueData:getCabinetData(cookerProducts,3);
					flueProduct = addCookerProduct(o,cw,flue.vo.objectInfo);
					flueProduct.isLock = true;
				}
				
				if(i==0 && type=="corner")
				{
					var door:XML = CabinetLib.lib.getDoor("ground_cabinet","left",900);
				}
				else if(i==len-1 && type=="corner")
				{
					door = CabinetLib.lib.getDoor("ground_cabinet","right",900);
				}
				else if(xml.door!=undefined)
				{
					door = xml.door[0];
				}
				else
				{
					door = null;
				}
				
				start += width*0.5;
				xml.x = start;
				//trace(i+":"+xml.x);
				
				xml = CabinetLib.lib.getCabinetData(id);
				
				var p:Product2D = this.createGroundCabinet(xml,cw,start,door,elec);
				sceneGroundCabinets.push(p.vo);
				
				this.createCabinetPlate(cw,width,80,10,start,0,520,CabinetType.LEG_BAFFLE);//创建柜腿挡板
			}
			
			//trace("list:"+list);
			var xml0:XML = list[0];
			var type0:String = xml0.flag;
			var width0:int = xml0.width;
			if(type0=="corner")
			{
				tx0 = xml0.x-400-1.5;
				//trace("xml0.x:"+xml0.x);
				//trace("-----head x:"+tx0);
				var po:ProductObject = this.createCabinetPlate(cw,500,720,16,tx0,80,551,CabinetType.DOOR_PLANK);//在插角地柜左侧创建封板
				sceneGroundCabinets.push(po);
			}
			else if(ht==ObstacleType.CORNER_CABINET)//当前的柜子顶着另一边的拐角柜
			{
				var w:Number = x0-cw.wall.width*0.5-550+offset;//计算挡板宽度
				po = this.createCabinetPlate(cw,w,720,16,x0+offset-1.5,80,551,CabinetType.DOOR_PLANK);//创建拐角缝挡板
				sceneGroundCabinets.push(po);
				this.createCabinetPlate(cw,w+30,80,10,x0+offset,0,520,CabinetType.LEG_BAFFLE);//创建拐角腿挡板，长度延伸30,至相邻插角地柜的柜腿挡板
			}
			else if(ht==ObstacleType.WALL || ht==ObstacleType.OBJECT)//柜子顶墙有间隙
			{
				w = x0-cw.wall.width*0.5+offset;
				if(w>1)
				{
					po = this.createCabinetPlate(cw,w,720,16,x0+offset,80,551,CabinetType.DOOR_PLANK);//柜子顶墙或障碍物时，缝隙封板
					sceneGroundCabinets.push(po);
					this.createCabinetPlate(cw,w,80,10,x0+offset,0,520,CabinetType.LEG_BAFFLE);//柜子顶墙或障碍物时，柜腿封板
				}
			}
			else if(ht==ObstacleType.HOLE || ht==ObstacleType.NULL)//柜子顶门边或者什么都不靠
			{
				this.createCabinetPlate(cw,10,80,520,x0+offset+10,0,0,CabinetType.LEG_BAFFLE);//柜子头上什么都没有时，侧面柜腿封板
			}
			
			var xml1:XML = list[len-1];
			var type1:String = xml1.flag;
			var width1:int = xml1.width;
			var tx1:Number = xml1.x;
//			trace("----et:"+et,x1,tx1);
			
			if(type1=="corner")//最尾端是拐角柜
			{
				var tx0:Number = tx1 - width1 + 400 + 1.5;//拐角柜门右则位置
				//trace("xml1.x:"+xml1.x);
				//trace("-----end x:"+tx0);
				po = this.createCabinetPlate(cw,500,720,16,tx0+500,80,551,CabinetType.DOOR_PLANK);//在插角地柜右侧创建封板
				sceneGroundCabinets.push(po);
			}
			else if(et==ObstacleType.CORNER_CABINET)//最尾部顶着拐角柜
			{
				w = x1-tx1+50;
				po = this.createCabinetPlate(cw,w,720,16,tx1+w+1.5,80,551,CabinetType.DOOR_PLANK);//创建拐角缝挡板
				sceneGroundCabinets.push(po);
				this.createCabinetPlate(cw,w,80,10,tx1+w,0,520,CabinetType.LEG_BAFFLE);//创建拐角腿挡板，长度与插角地柜等长
			}
			else if(et==ObstacleType.WALL || et==ObstacleType.OBJECT)
			{
				x1 = cw.localEnd.x;
				w = x1 - tx1;
				if(w>1)
				{
					po = this.createCabinetPlate(cw,w,720,16,x1,80,551,CabinetType.DOOR_PLANK);//柜子顶墙或障碍物时，缝隙封板
					sceneGroundCabinets.push(po);
					this.createCabinetPlate(cw,w,80,10,x1,0,520,CabinetType.LEG_BAFFLE);//柜子顶墙或障碍物时，柜腿封板
				}
			}
			else if(et==ObstacleType.HOLE || et==ObstacleType.NULL)//柜子顶门边或者什么都不靠
			{
				this.createCabinetPlate(cw,10,80,520,tx1,0,0,CabinetType.LEG_BAFFLE);//柜子头上什么都没有时，侧面柜腿封板
			}
		}
		
		private function setProductPos(p:Product2D,cw:CrossWall,x:Number):void
		{
			var wo:WallObject = p.vo.objectInfo;
			x += wo.width*0.5;
			cabinetCtr.setCabinetPos(p,cw,x,wo.y,wo.z);
			wo.x = x;
		}
		
		/**
		 * 地柜摆放位置偏移量
		 */
		private function getStartOffset(cw:CrossWall,x0:Number,x1:Number,ht:String,et:String,hc:Boolean,ec:Boolean,aw:Number,gw:Number):Number
		{
			var startOffset:Number = 0;
			if(hc)//转角柜开头
			{
				if(x0-cw.localHead.x<100)
				{
					startOffset = cw.localHead.x+100-x0;
				}
			}
			else if(ec)//转角柜结尾
			{
				if(cw.localEnd.x-x1<100)//转角柜至墙的间距至少为100
				{
					startOffset = aw - gw - (x1 + 100 - cw.localEnd.x);
				}
			}
			else if(ht==et)//墙洞，转角柜，墙，障碍物
			{
				startOffset = (aw-gw)/2;
			}
			else if(ht==ObstacleType.HOLE)
			{
				startOffset = 50;
			}
			else if(et==ObstacleType.CORNER_CABINET || et==ObstacleType.OBJECT || et==ObstacleType.WALL)
			{
				startOffset = aw - gw;
			}
			return startOffset;
		}
		
		/**
		 * 吊柜摆放位置偏移量
		 * 
		 */
		private function getStartOffset2(cw:CrossWall,x0:Number,x1:Number,ht:String,et:String,hc:Boolean,ec:Boolean,aw:Number,gw:Number):Number
		{
			var startOffset:Number = 0;
			if(ht==et)//墙洞，转角柜，墙，障碍物
			{
				startOffset = (aw-gw)/2;
			}
			else if(ht==ObstacleType.HOLE)
			{
				startOffset = 50;
			}
			else if(et==ObstacleType.CORNER_CABINET || et==ObstacleType.OBJECT || et==ObstacleType.WALL)
			{
				startOffset = aw - gw;
			}
			return startOffset;
		}
		
		private function getGroupWidth(cs:Array):int
		{
			var n:int = 0;
			var len:int = cs.length;
			for(var i:int=0;i<len;i++)
			{
				var xml:XML = cs[i];
				var w:int = xml.width;
				n += w;
			}
			return n;
		}
		
		/**
		 * 根据门洞来调整台面分区
		 * @param tables 初始台面分区，每个台面分区由1个或2个以上相连的墙面组成
		 * @param flags 水盆和灶台的定位标志，与每个台面分区相对应，每个台面分区最多可能有2个定位标志，相应的，其它的台面分区就不会有定位标志了
		 * @return
		 * [[{cw:CrossWall,x0,x1,flags:[flag,flag],flueFlag,drainerFlag,headCorner,endCorner,
		 * 		groundObjects:[{x0,x1,headCorner,endCorner,headType,endType,flueFlag,drainerFlag,flags:[flag,flag],cabinets:[{id,width,data,type,x},{}]},{}],
		 * 		  wallObjects:[{x0,x1,headCorner,endCorner,headType,endType,flueFlag,drainerFlag,flag,			   cabinets:[{id,width,data,type,x},{}]},{}]},
		 * 	{cw...}],
		 * [...]]
		 * 
		 * cw：当前台面分区中的一个墙面，x0：墙面有效区域的起始位置，x1：墙面有效区域的结束位置，
		 * 
		 * flags：水盆灶台的定位标志，在以后挖水盆洞时还要用到
		 * 
		 * groundObjects：可放置地柜的区间列表，x0：区间开始，x1：区间结束，headCorner、endCorner：区间的首尾是否放置转角柜，
		 * 										headType、endType：区间首尾端的障碍物类型，
		 * 										flags：水盆灶台定位标志，放置水盆及灶台模型时，定位用
		 * 										cabinets：区间内要放置的厨柜列表，
		 * 												id：厨柜的id编号 width：厨柜的宽度 data：相关的产品数据 type：相关的产品类型 x：厨柜的位置
		 * 
		 *   wallObjects：可放置吊柜的区间列表，x0：区间开始，x1：区间结束，headCorner、endCorner：区间的首尾是否放置转角柜，
		 * 										headType、endType：区间首尾端的障碍物类型，
		 * 										flag：灶台定位标志，放置烟机模型时，定位用
		 * 										cabinets：区间内要放置的厨柜列表，
		 * 												id：厨柜的id编号 width：厨柜的宽度 data：相关的产品数据 type：相关的产品类型 x：厨柜的位置
		 * 
		 * 障碍物类型(wall：厨柜顶墙,hole：墙洞,cabinet：邻墙的拐角柜,object：其它的障碍物)
		 * 相关的产品数据：水盆，灶台，烟机，消毒柜，烤箱
		 * 相关产品的类型：drainer,flue,cookerHood,sterilizer,oven
		 */
		private function resetTablesArea(tables:Array):Array
		{
			resetTablesArea1(tables);
			return resetTablesArea2(tables);
		}
		
		private function resetTablesArea1(tables:Array):void
		{
			var wa0:WallArea;
			
			var tlen:int = tables.length;
			
			for(var i:int=0;i<tlen;i++)
			{
				var cws:Array = tables[i];//组成台面的墙面
				var clen:int = cws.length;
				
				wa0 = null;
				
				for(var j:int=0;j<clen;j++)
				{
					var cw:CrossWall = cws[j];
					var wall:Wall = cw.wall;
					var areas:Array = wall.selectorArea;
					var len:int = areas.length;
					
					for(var k:int=0;k<len;k++)
					{
						var wa:WallArea = areas[k].vo;
						
						if(!wa.enable)//低于容纳台面区域的最小长度时，将跳过
						{
							wa0 = null;
							continue;
						}
						
						if(wa0)//与当前区域相连的前区域，处理拐角
						{
							var tx0:Number = wa0.x1 - wa0.x0;
							var tx1:Number = wa.x1 - wa.x0;
							
							if(wa0.headCorner)tx0 -= 1000;//前区域头部有拐角柜
							if(tx0>tx1)
							{
								wa0.endCorner = true;//前区域尾部放拐角柜
								wa0.endType1 = ObstacleType.WALL;//前区域拐角柜顶墙
								
								wa.headCorner = false;
								wa.headType1 = ObstacleType.CORNER_CABINET;//此区域头部顶前区域尾部拐角柜
							}
							else
							{
								wa0.endCorner = false;
								wa0.endType1 = ObstacleType.CORNER_CABINET;//前区域尾部顶此区域头部拐角柜
								
								wa.headCorner = true;//此区域头部放拐角柜
								wa.headType1 = ObstacleType.WALL;//此区域拐角柜顶墙
							}
						}
						else
						{
							if(!wa.headType1)
							{
								wa.headCorner = false;
								wa.headType1 = k==0?ObstacleType.WALL:ObstacleType.HOLE;
								if(wa.x0-wa.minX>=WallArea.MinDist)wa.headType1 = ObstacleType.NULL;
							}
						}
						
						if(!wa.endType1)
						{
							wa.endCorner = false;
							wa.endType1 = k==len-1?ObstacleType.WALL:ObstacleType.HOLE;
							if(wa.maxX-wa.x1>=WallArea.MinDist)wa.endType1 = ObstacleType.NULL;
						}
						
						wa0 = wa;
					}
				}
			}
		}
		
		private function resetTablesArea2(tables:Array):Array
		{
			var tss:Array = [];
			var ts:Array;
			var needCreateSubArea:Boolean;//是否需要创建新台面分区
			
			var tlen:int = tables.length;
			for(var i:int=0;i<tlen;i++)
			{
				var cws:Array = tables[i];//组成台面的墙面
				var clen:int = cws.length;
				
				for(var j:int=0;j<clen;j++)
				{
					var cw:CrossWall = cws[j];
					var wall:Wall = cw.wall;
					var areas:Array = wall.selectorArea;
					var len:int = areas.length;
					
					for(var k:int=0;k<len;k++)
					{
						var wa:WallArea = areas[k].vo;
						
						if(!wa.enable)//低于容纳台面区域的最小长度时，将跳过
						{
							if(k==len-1 && j<clen-1)//在同一个分区里，前一面墙的最后一个区域不可用时，下一面墙将是一个独立分区的开始
							{
								needCreateSubArea = true;
							}
							continue;
						}
						
						if(j==0 || k>0 || needCreateSubArea)
						{
							needCreateSubArea = false;
							
							ts = [];//创建新的台面分区
							tss.push(ts);
						}
						
						addTableSubarea(ts,cw,wa.x0,wa.x1,wa.headCorner,wa.endCorner,wa.headType1,wa.endType1);
					}
				}
			}
			
			return tss;
		}
		
		/*private function resetTablesArea3(tables:Array):Array
		{
			var tss:Array = [];
			var ts:Array;
			var needCreateSubArea:Boolean;//是否需要创建新台面分区
			var headType:String,endType:String;
			var headCorner:Boolean,endCorner:Boolean;
			
			var tlen:int = tables.length;
			for(var i:int=0;i<tlen;i++)
			{
				var cws:Array = tables[i];//组成台面的墙面
				//var flags:Array = flagss[i];//每个台面区域的定位标志
				
				var clen:int = cws.length;
				for(var j:int=0;j<clen;j++)
				{
					var cw:CrossWall = cws[j];
					var wall:Wall = cw.wall;
					var x0:Number = cw.localHead.x;
					
					var doors:Array = wall.getDoorsOfWall();
					var dlen:int = doors.length;
					
					if(dlen==0)//当前墙面上没有门
					{
						var x1:Number = cw.localEnd.x;
					}
					else//有门时，一个独立台面被分割成多个独立台面
					{
						var hole:WallHole = doors[0];
						x1 = hole.x;
					}
					
					var dx:Number = x1 - x0;
					if(j==0)//新的台面分区开始
					{
						if(dx>=50+800+50)//且空间够容纳常规规格厨柜
						{
							ts = [];//创建新的台面分区
							tss.push(ts);
							
							headCorner = false;//刚开始不用转角柜
							headType = ObstacleType.WALL;//从墙面交接处开始
							
							if(dlen>0)//有门洞
							{
								endType = ObstacleType.HOLE;
								endCorner = false;
							}
							else
							{
								if(clen==1)//此台面分区只有一面墙
								{
									endType = ObstacleType.WALL;
									endCorner = false;
								}
								else//还有邻墙
								{
									var cw2:CrossWall = cws[1];
									if(cw.validLength>=cw2.validLength)//此处忽略了（未处理）cw2中有门的情况
									{
										endCorner = true;//长度长的墙面放置拐角柜
										endType = ObstacleType.WALL;//拐角柜顶墙
									}
									else
									{
										endCorner = false;//拐角柜放置到相邻墙面上
										endType = ObstacleType.CORNER_CABINET;//此墙顶到邻墙拐角柜上
									}
								}
							}
							
							addTableSubarea(ts,cw,x0,x1,headCorner,endCorner,headType,endType);
							needCreateSubArea = false;
						}
						else
						{
							needCreateSubArea = true;//如果有相关联的区域，因为此处断开了，所以要创建新的分区
						}
					}
					else if(dx>550+50+300+50)//台面区域拐角处的第二面墙，空间必须至少能再容纳一个最小规格的厨柜，才能拐过来
					{
						if(needCreateSubArea)//与前面墙体的台面区域断开了，所以要创建新的台面分区
						{
							ts = [];//创建新的台面分区
							tss.push(ts);
							
							headCorner = false;//刚开始不用转角柜
							headType = ObstacleType.WALL;//从墙面交接处开始
						}
						else
						{
							var before:Object = ts[ts.length-1];//前面相邻墙面的数据
							//trace("---------before.endCorner:"+before.endCorner);
							if(!before.endCorner)//前面墙尾没放转角柜，那么此墙首要放置
							{
								headCorner = true;
								headType = ObstacleType.WALL;
							}
							else
							{
								headCorner = false;//拐角柜放置到相邻墙面上
								headType = ObstacleType.CORNER_CABINET;//此墙顶到邻墙拐角柜上
							}
						}
						
						if(dlen>0)//右则有门洞时
						{
							endCorner = false;
							endType = ObstacleType.HOLE;
						}
						else
						{
							if(j==clen-1)//当前已是台面区域的末尾
							{
								endCorner = false;
								endType = ObstacleType.WALL;
							}
							else//台面区域还有墙面未处理
							{
								cw2 = cws[j+1];
								if(x1-x0>cw2.validLength)
								{
									endCorner = true;//长度长的墙面放置拐角柜
									endType = ObstacleType.WALL;//拐角柜顶墙
								}
								else
								{
									endCorner = false;//拐角柜放置到相邻墙面上
									endType = ObstacleType.CORNER_CABINET;//此墙顶到邻墙拐角柜上
								}
							}
						}
						
						addTableSubarea(ts,cw,x0,x1,headCorner,endCorner,headType,endType);
					}
					
					if(dlen>0)//处理门右则的区域
					{
						for(var k:int=1;k<dlen;k++)
						{
							x0 = hole.x + hole.width;
							
							hole = doors[k];
							x1 = hole.x;
							
							if(x1-x0>=50+800+50)//在两个门之间的空间，要能够放下一个常规规格的厨柜，才允许设置台面分区
							{
								ts = [];
								tss.push(ts);
								
								addTableSubarea(ts,cw,x0,x1,false,false,ObstacleType.HOLE,ObstacleType.HOLE);
							}
						}
						
						x0 = hole.x + hole.width;
						x1 = cw.localEnd.x;
						
						if(x1-x0>50+900+50)//在门右则至邻墙之间的间距，要能够放下一个常规规格的厨柜，才允许设置台面分区
						{
							ts = [];
							tss.push(ts);
							
							if(j==clen-1)//当前已是台面区域的末尾
							{
								endCorner = false;
								endType = ObstacleType.WALL;
							}
							else//台面区域还有墙面未处理
							{
								cw2 = cws[j+1];
								if(x1-x0>cw2.validLength)
								{
									endCorner = true;//长度长的墙面放置拐角柜
									endType = ObstacleType.WALL;//拐角柜顶墙
								}
								else
								{
									endCorner = false;//拐角柜放置到相邻墙面上
									endType = ObstacleType.CORNER_CABINET;//此墙顶到邻墙拐角柜上
								}
							}
							
							addTableSubarea(ts,cw,x0,x1,false,endCorner,ObstacleType.HOLE,endType);
							needCreateSubArea = false;
						}
						else
						{
							needCreateSubArea = true;//如果有相关联的区域，因为此处断开了，所以要创建新的分区
						}
					}
				}
			}
			
			return tss;
		}*/
		
		/**
		 * 
		 */
		/**
		 * 设置一个台面分区中的一个墙面的数据
		 * @param ts：当前的台面分区
		 * @param cw：当前墙面
		 * @param x0：墙面有效区域的起始位置
		 * @param x1：墙面有效区域的结束位置
		 * @param flags：水盆灶台的定位标志，要检测是否在有效区域内
		 * @param headCorner：墙首是否放置转角柜
		 * @param endCorner：墙尾是否放置转角柜
		 * @param headType：区域首端分隔物类型
		 * @param endType：区域尾端分隔物类型
		 * 
		 */
		private function addTableSubarea(ts:Array,cw:CrossWall,x0:Number,x1:Number,headCorner:Boolean,endCorner:Boolean,headType:String,endType:String):void
		{
			trace("addTableSubarea headCorner:"+headCorner+" endCorner:"+endCorner+" headType:"+headType+" endType:"+endType+" x0:"+x0+" x1:"+x1);
			var tableData:Object = {cw:cw,x0:x0,x1:x1,headCorner:headCorner,endCorner:endCorner,headType:headType,endType:endType};//
			ts.push(tableData);
			
			tableData.drainerFlag = testLocationFlag(drainerFlag.vo,cw,x0,x1)?drainerFlag:null;
			tableData.flueFlag = testLocationFlag(flueFlag.vo,cw,x0,x1)?flueFlag:null;
			
			/*var a:Array = getTestFlags(cw,x0,x1,flags);
			tableData.flags = a;*/
			
			setGroundObjectArea(tableData,cw,x0,x1,headCorner,endCorner,headType,endType);
			
			//setWallObjectArea();
		}
		
		/**
		 * 设置吊柜区间
		 * 
		 */
		private function setWallObjectArea(tableData:Object,cw:CrossWall,x0:Number,x1:Number,headCorner:Boolean,endCorner:Boolean,headType:String,endType:String):void
		{
			var wallObjects:Array = [];
			tableData.wallObjects = wallObjects;
			//trace("-----------setWallObjectArea-----------");
			
			if(headType==ObstacleType.CORNER_CABINET)//首端相邻墙放置拐角柜
			{
				x0 += 330+50;//起始位置让出拐角柜的空间
			}
			
			if(endType==ObstacleType.CORNER_CABINET)//尾端相邻墙放置拐角柜
			{
				x1 -= 380;//结束位置让出拐角柜的空间
			}
			
			var objects:Array = [];
			cw.getWallObjectOfPos(x0,x1,objects);//查找区间内已经存在的物体，并作为障碍物来区隔当前墙面区域
			
			//trace("objects:"+objects);
			
			var alen:int = objects.length;
			var tx0:Number,tx1:Number;
			var headCorner2:Boolean,endCorner2:Boolean;
			var headType2:String,endType2:String;
			
			tx0 = x0;
			headCorner2 = headCorner;
			headType2 = headType;
			
			if(alen==0)//区域内没有障碍物
			{
				tx1 = x1;
				endCorner2 = endCorner;
				endType2 = endType;
			}
			else//有障碍物，计算第一个区间
			{
				var wo:WallObject = objects[0];
				tx1 = wo.x - wo.width;
				endCorner2 = false;
				endType2 = getWallObjectType(wo);
			}
			
			if(tx1-tx0>=300+30)//判断空间是否可以放置最小规格厨柜
			{
				//var o:Object = getCabinetAreaData(cw,tx0,tx1,headCorner2,endCorner2,headType2,endType2);
				var o:Object = {x0:tx0,x1:tx1,headCorner:headCorner2,endCorner:endCorner2,headType:headType2,endType:endType2};
				wallObjects.push(o);
			}
			
			if(alen>0)//计算障碍物后面的区间
			{
				for(var i:int=1;i<alen;i++)//障碍物之间的区间
				{
					if(o)
					{
						headCorner2 = false;
					}
					else
					{
						headCorner2 = headCorner;
					}
					
					headType2 = endType2;
					
					tx0 = wo.x;
					wo = objects[i];
					tx1 = wo.x - wo.width;
					
					if(tx1-tx0>=300)
					{
						endCorner2 = false;
						endType2 = getWallObjectType(wo);
						
						//o = getCabinetAreaData(cw,tx0,tx1,headCorner2,endCorner2,headType2,endType2);
						o = {x0:tx0,x1:tx1,headCorner:headCorner2,endCorner:endCorner2,headType:headType2,endType:endType2};
						wallObjects.push(o);
					}
				}
				
				//障碍物最后面的区间
				tx0 = wo.x;
				tx1 = x1;
				
				if(tx1-tx0>=300)
				{
					if(o)
					{
						headCorner2 = false;
					}
					else
					{
						headCorner2 = headCorner;
					}
					
					headType2 = endType2;
					
					endCorner2 = endCorner;
					endType2 = endType;
					
					//o = getCabinetAreaData(cw,tx0,tx1,headCorner2,endCorner2,headType2,endType2);
					o = {x0:tx0,x1:tx1,headCorner:headCorner2,endCorner:endCorner2,headType:headType2,endType:endType2};
					wallObjects.push(o);
				}
				else if(o)//重新设置前一区间的尾部标志
				{
					o.endCorner=endCorner;
				}
			}
		}
		
		private function getWallObjectType(wo:WallObject):String
		{
			var type:String;
			if(wo.object is WallHole)//窗口
			{
				type = ObstacleType.HOLE;
			}
			else
			{
				var po:ProductObject = wo.object;
				if(po && po.view2d == hoodProduct)//烟机
				{
					type = ObstacleType.HOOD;
				}
				else
				{
					type = ObstacleType.OBJECT;
				}
			}
			return type;
		}
		
		//设置地柜区间
		//groundObjects:[{x0,x1,headCorner,endCorner,headType,endType,flags:[flag,flag],cabinets:[{id,width,data,type,x},{}]},{}]
		private function setGroundObjectArea(tableData:Object,cw:CrossWall,x0:Number,x1:Number,headCorner:Boolean,endCorner:Boolean,headType:String,endType:String):void
		{
			var groundObjects:Array = [];
			tableData.groundObjects = groundObjects;
			
			if(headType==ObstacleType.CORNER_CABINET)//首端相邻墙放置拐角柜
			{
				x0 += 550+50;//起始位置让出拐角柜的空间
			}
			
			if(endType==ObstacleType.CORNER_CABINET)//尾端相邻墙放置拐角柜
			{
				x1 -= 600;//结束位置让出拐角柜的空间
			}
			
			var objects:Array = [];
			cw.getGroundObjectOfPos(x0,x1,objects);//查找区间内已经存在的物体，并作为障碍物来区隔当前墙面区域
			var alen:int = objects.length;
			var tx0:Number,tx1:Number;
			var headCorner2:Boolean,endCorner2:Boolean;
			var headType2:String,endType2:String;
			
			tx0 = x0;
			headCorner2 = headCorner;
			headType2 = headType;
			
			if(alen==0)//区域内没有障碍物
			{
				tx1 = x1;
				endCorner2 = endCorner;
				endType2 = endType;
			}
			else//有障碍物，计算第一个区间
			{
				var wo:WallObject = objects[0];
				tx1 = wo.x - wo.width;
				endCorner2 = false;
				endType2 = ObstacleType.OBJECT;
			}
			
			if(tx1-tx0>=300+30)//判断空间是否可以放置最小规格厨柜
			{
				var o:Object = getCabinetAreaData(cw,tx0,tx1,headCorner2,endCorner2,headType2,endType2);
				groundObjects.push(o);
			}
			
			if(alen>0)//计算障碍物后面的区间
			{
				for(var i:int=1;i<alen;i++)//障碍物之间的区间
				{
					tx0 = wo.x;
					wo = objects[i];
					tx1 = wo.x - wo.width;
					
					if(tx1-tx0>=300)
					{
						if(!o)//前面区间不够放置厨柜
						{
							headCorner2 = headCorner;
						}
						else
						{
							headCorner2 = false;
						}
						endCorner2 = false;
						headType2 = ObstacleType.OBJECT;
						endType2 = ObstacleType.OBJECT;
						
						o = getCabinetAreaData(cw,tx0,tx1,headCorner2,endCorner2,headType2,endType2);
						groundObjects.push(o);
					}
				}
				
				//障碍物最后面的区间
				tx0 = wo.x;
				tx1 = x1;
				
				if(tx1-tx0>=300)
				{
					//headCorner2 = false;
					if(!o)//前面区间不够放置厨柜
					{
						headCorner2 = headCorner;
					}
					else
					{
						headCorner2 = false;
					}
					headType2 = ObstacleType.OBJECT;
					endCorner2 = endCorner;
					endType2 = endType;
					
					o = getCabinetAreaData(cw,tx0,tx1,headCorner2,endCorner2,headType2,endType2);
					groundObjects.push(o);
				}
				else if(o)//重新设置前一区间的尾部标志
				{
					o.endCorner=endCorner;
				}
			}
		}
		
		//设置厨柜区间数据
		private function getCabinetAreaData(cw:CrossWall,x0:Number,x1:Number,headCorner:Boolean,endCorner:Boolean,headType:String,endType:String):Object
		{
			var o:Object = {x0:x0,x1:x1,headCorner:headCorner,endCorner:endCorner,headType:headType,endType:endType};
			/*var a:Array = getTestFlags(cw,x0,x1,flags);
			o.flags = a;
			
			var d:* = hasFlag(a,drainerFlag)?drainerFlag:null;
			var f:* = hasFlag(a,flueFlag)?flueFlag:null;*/
			
			var d:*= testLocationFlag(drainerFlag.vo,cw,x0,x1)?drainerFlag:null;
			o.drainerFlag = d;
			
			var f:*= testLocationFlag(flueFlag.vo,cw,x0,x1)?flueFlag:null;
			o.flueFlag = f;
			
			return o;
		}
		
		/*private function hasFlag(flags:Array,flag:*):Boolean
		{
			for each(var f:* in flags)
			{
				if(flag==f)
				{
					return true;
				}
			}
			return false;
		}*/
		
		/*private function getGroundCabinetGroup(headCorner:Boolean,endCorner:Boolean,flags:Array):Array
		{
			var a:Array = [];
			return a;
		}*/
		
		/*private function getTestFlags(cw:CrossWall,x0:Number,x1:Number,flags:Array):Array
		{
			var a:Array = [];
			for each(var flag:* in flags)
			{
				if(testLocationFlag(flag,cw,x0,x1))
				{
					a.push(flag);
				}
			}
			return a;
		}*/
			
		/*private function _createCabinetTable(tables:Array,flags:Array,depth:int=600,holeWidth:int=700,holeDepth:int=400):void
		{
			var tss:Array = [],ts:Array = [];
			var hs:Array = [];
			var cw:CrossWall;
			var co:Object;
			var flag:Product2D;
			
			var len:int = tables.length;
			for(var i:int=0;i<len;i++)//进行计算每一个独立台面
			{
				var cws:Array = tables[i];
				//var flags:Array = holes[i];
				flag = flags[i];
				
				var clen:int=cws.length;
				for(var j:int=0;j<clen;j++)//一个独立台面所关联的几个墙面
				{
					cw = cws[j];
					var p0:Point3D = cw.localHead;
					
					var wall:Wall = cw.wall;
					var doors:Array = getDoorsOfWall(wall.holes);
					var dlen:int = doors.length;
					
					if(dlen==0)//没有门的情况
					{
						var p1:Point3D = cw.localEnd;
						
						if(j==0)
						{
							ts = [];
							tss.push(ts);
						}
						
						if(testLocationFlag(flag,cw,p0.x,p1.x))
						{
							hs.push(flag);
							flag = null;
						}
						else if(j==clen-1)//到最后一个墙面还没有匹配上洞口标志
						{
							hs.push(null);
						}
						
						addTableData(cw,p0,p1,ts);
					}
					else//有门时，一个独立台面被分割成多个独立台面
					{
						var hole:WallHole = doors[0];
						p1 = p0.clone();
						p1.x = hole.x;
						
						if(j==0)
						{
							ts = [];
							tss.push(ts);
						}
						
						if(testLocationFlag(flag,cw,p0.x,p1.x))
						{
							hs.push(flag);
							flag = null;
						}
						else if(j==clen-1)//到最后一个墙面还没有匹配上洞口标志
						{
							hs.push(null);
						}
						
						addTableData(cw,p0,p1,ts);
						
						for(var k:int=1;k<dlen;k++)
						{
							p0 = p1.clone();
							p0.x = hole.x + hole.width;
							
							hole = doors[k];
							p1 = p0.clone();
							p1.x = hole.x;
							
							ts = [];
							tss.push(ts);
							
							if(testLocationFlag(flag,cw,p0.x,p1.x))
							{
								hs.push(flag);
								flag = null;
							}
							else if(j==clen-1)//到最后一个墙面还没有匹配上洞口标志
							{
								hs.push(null);
							}
							
							addTableData(cw,p0,p1,ts);
						}
						
						p0 = p1.clone();
						p0.x = hole.x + hole.width;
						
						p1 = cw.localEnd;
						
						ts = [];
						tss.push(ts);
						
						if(testLocationFlag(flag,cw,p0.x,p1.x))
						{
							hs.push(flag);
							flag = null;
						}
						else if(j==clen-1)//到最后一个墙面还没有匹配上洞口标志
						{
							hs.push(null);
						}
						
						addTableData(cw,p0,p1,ts);
					}
				}
			}
			
			_createCabinetTable2(tss,hs,depth,holeWidth,holeDepth);
		}*/
		
		/**
		 * 测试定位标志是否完整的放在墙面的指定区间内
		 * @param flag
		 * @param cw
		 * @param x0
		 * @param x1
		 * @return 
		 * 
		 */
		private function testLocationFlag(flag:ProductObject,cw:CrossWall,x0:Number,x1:Number):Boolean
		{
			if(!flag)return false;
			var o:WallObject = flag.objectInfo;
			if(!o || o.crossWall!=cw)return false;
			if(x0-(o.x-o.width)>0.1 || o.x-x1>0.1)return false;//此处只考虑了墙面为正面的情况
			return true;
		}
		
		private function addTableData(cw:CrossWall,h:Point3D,e:Point3D,ts:Array):void
		{
			var co:Object = {};
			co.cw = cw;
			co.h = h;
			co.e = e;
			ts.push(co);
		}
		
		private function createCabinetTable3(tabless:Array,depth:int=600):void
		{
			var tlen:int = tabless.length;
			for(var i:int=0;i<tlen;i++)
			{
				var tables:Array = tabless[i];//每个独立台面分区
				
				var points:Array = [];
				var dangshui:Array = [];
				
				var tableData:Object = tables[0];
				var cw:CrossWall = tableData.cw;
				var x0:Number = tableData.x0;
				var x1:Number = tableData.x1;
				
				var h:Point3D = cw.localHead.clone();
				h.x = x0;
				
				var e:Point3D = h.clone();
				e.x = x1;
				
				var head:Point = new Point();
				var end:Point = new Point();
				
				offsetCrossWall(cw,depth,head,end,h,e);
				
				var p:Point = cw.isHead?head:end;
				points.push(p);
				var headType:String = tableData.headType;
				if(headType!=ObstacleType.HOLE && headType!=ObstacleType.NULL)
				{
					dangshui.push(p);//挡水的第一个点坐标（为台面外沿，挡水终点坐标）
				}
				//dangshui.unshift(p);
				
				var tlen2:int = tables.length;
				for(var j:int=1;j<tlen2;j++)//组成台面的每个墙面
				{
					tableData = tables[j];
					cw = tableData.cw;
					x0 = tableData.x0;
					x1 = tableData.x1;
					
					h = cw.localHead.clone();
					h.x = x0;
					e = h.clone();
					e.x = x1;
					
					var head2:Point = new Point();
					var end2:Point = new Point();
					
					offsetCrossWall(cw,depth,head2,end2,h,e);
					
					var cp:Point = Geom.intersection(head,end,head2,end2);//计算台面外沿相交点坐标
					//trace("cp:"+cp);
					points.push(cp);
					
					head = head2;
					end = end2;
				}
				
				p = cw.isHead?end:head;
				points.push(p);
				var endType:String = tableData.endType;
				if(endType!=ObstacleType.HOLE && endType!=ObstacleType.NULL)
				{
					dangshui.push(p);//台面外沿，挡水起始坐标
				}
				//dangshui.unshift(p);
				
				p = turnPoint3d(cw.isHead?cw.wall.localToGlobal(e):cw.wall.localToGlobal(h));
				points.push(p);
				dangshui.push(p);//台面内沿起始点，挡水坐标点
				//dangshui.unshift(p);
				
				for(j=tlen2-2;j>=0;j--)
				{
					tableData = tables[j];
					
					cw = tableData.cw;
					x0 = tableData.x0;
					x1 = tableData.x1;
					
					h = cw.localHead.clone();
					h.x = x0;
					e = h.clone();
					e.x = x1;
					
					p = turnPoint3d(cw.isHead?cw.wall.localToGlobal(e):cw.wall.localToGlobal(h));
					points.push(p);
					dangshui.push(p);//台面内沿拐角点，挡水坐标点
					//dangshui.unshift(p);
				}
				
				p = turnPoint3d(cw.isHead?cw.wall.localToGlobal(h):cw.wall.localToGlobal(e));
				points.push(p);
				dangshui.push(p);//台面内沿最后一个点，挡水坐标点
				//dangshui.unshift(p);
				
				if(headType!=ObstacleType.HOLE && headType!=ObstacleType.NULL)
				{
					dangshui.push(dangshui.shift());//将一开始取到点放到最后的位置，形成一个沿墙的逆时针挡水起止点
				}
				//dangshui.unshift(dangshui.pop());
				trace("dangshui:"+dangshui);
				
				//trace(points);
				
				if(isDrainerArea(tables))//检测是否为放置水盆的区域
				{
					var holeWidth:int = drainerProduct.objectInfo.width;
					var holeDepth:int = drainerProduct.objectInfo.depth;
					
					var flag:WallObject = drainerFlag.vo.objectInfo;
					
					var ww:Number = drainerFlag.wall.vo.width*0.5 + depth*0.5;
					
					var x:int = flag.x-flag.width*0.5;
					var y:int = flag.crossWall.isHead?-ww:ww;
					
					var dx:int = holeWidth*0.5;
					var dy:int = holeDepth*0.5;
					
					var p1:Point = new Point(x+dx,y+dy);
					var p2:Point = new Point(x-dx,y+dy);
					var p3:Point = new Point(x-dx,y-dy);
					var p4:Point = new Point(x+dx,y-dy);
					
					var wall:Wall = drainerFlag.wall.vo;
					wall.localToGlobal2(p1,p1);
					wall.localToGlobal2(p2,p2);
					wall.localToGlobal2(p3,p3);
					wall.localToGlobal2(p4,p4);
					
					var hole:Array = [p1,p2,p3,p4];
					
					createTableMesh(dangshui,points,hole,30);
				}
				else
				{
					createTableMesh(dangshui,points);
					
				}
			}
			
			addTableMeshs();
		}
		
		private function isDrainerArea(tables:Array):Boolean
		{
			if(!drainerProduct)return false;
			
			var o:WallObject = drainerProduct.objectInfo;
			//trace(o);
			for each(var tableData:Object in tables)
			{
				var cw:CrossWall = tableData.cw;
				var x0:Number = tableData.x0;
				var x1:Number = tableData.x1;
				
				if(o.x-o.width>x0 && x1>o.x)return true;//此处只考虑了墙面为正面的情况
			}
			//trace("isDrainerArea2");
			return false;
		}
		
		/*private function _createCabinetTable2(tables:Array,holes:Array,depth:int=600,holeWidth:int=700,holeDepth:int=400):void
		{
			//removeTableMeshs();
			
			var tlen:int = tables.length;
			
			for(var k:int=0;k<tlen;k++)
			{
				var cws:Array = tables[k];
				//trace("cws:"+cws);
				var len:int = cws.length;
				//trace("len:"+len);
				
				var points:Array = [];
				
				//var cw:CrossWall = cws[0];
				var co:Object = cws[0];
				var cw:CrossWall = co.cw;
				var h:Point3D = co.h;
				var e:Point3D = co.e;
				
				var head:Point = new Point();
				var end:Point = new Point();
				offsetCrossWall(cw,depth,head,end,h,e);
				
				points.push(cw.isHead?head:end);
				
				for(var i:int=1;i<len;i++)
				{
					//cw = cws[i];
					co = cws[i];
					cw = co.cw;
					h = co.h;
					e = co.e;
					
					var head2:Point = new Point();
					var end2:Point = new Point();
					
					offsetCrossWall(cw,depth,head2,end2,h,e);
					
					var cp:Point = Geom.intersection(head,end,head2,end2);
					//trace("cp:"+cp);
					points.push(cp);
					
					head = head2;
					end = end2;
				}
				
				points.push(cw.isHead?end:head);
				
				//points.push(turnPoint3d(cw.isHead?cw.globalEnd:cw.globalHead));
				points.push(turnPoint3d(cw.isHead?cw.wall.localToGlobal(e):cw.wall.localToGlobal(h)));
				for(i=len-2;i>=0;i--)
				{
					co = cws[i];
					cw = co.cw;
					h = co.h;
					e = co.e; 
					points.push(turnPoint3d(cw.isHead?cw.wall.localToGlobal(e):cw.wall.localToGlobal(h)));
				}
				points.push(turnPoint3d(cw.isHead?cw.wall.localToGlobal(h):cw.wall.localToGlobal(e)));
				
				//trace("points:"+points);
				
				var pdt:Product2D = holes[k];
				if(pdt==cabinetCtr.drainerFlag)
				{
					holeWidth = drainerProduct.objectInfo.width;
					holeDepth = drainerProduct.objectInfo.depth;
					
					var ww:Number = pdt.wall.vo.width*0.5 + depth*0.5;
					var x:int = pdt.vo.objectInfo.x;
					var y:int = pdt.vo.objectInfo.crossWall.isHead?-ww:ww;
					//y = -ww;
					var dx:int = holeWidth*0.5;
					var dy:int = holeDepth*0.5;
					//trace("_drainer postion:"+x+"x"+y);
					//trace("_drainer hole:"+dx+"x"+dy);
					
					var p1:Point = new Point(x+dx,y+dy);
					var p2:Point = new Point(x-dx,y+dy);
					var p3:Point = new Point(x-dx,y-dy);
					var p4:Point = new Point(x+dx,y-dy);
					
					var wall:Wall = pdt.wall.vo;
					wall.localToGlobal2(p1,p1);
					wall.localToGlobal2(p2,p2);
					wall.localToGlobal2(p3,p3);
					wall.localToGlobal2(p4,p4);
					
					var hole:Array = [p1,p2,p3,p4];
					
					//var p:Point;// = pdt.wall.vo.localToGlobal2(new Point(pdt.vo.objectInfo.x,y));
					//p = new Point(pdt.vo.position.x,pdt.vo.position.z);
					createTableMesh(points,hole,30);
				}
				else
				{
					//var p0:Point = points[0];
					//p1 = points[2];
					//p = new Point(p0.x+(p1.x-p0.x)*0.5,p0.y+(p1.y-p0.y)*0.5);
					createTableMesh(points);
				}
			}
			
			addTableMeshs();
		}*/
		
		//三维点转换为二维点，去掉了高度信息
		private function turnPoint3d(p3d:Point3D):Point
		{
			return new Point(p3d.x,p3d.z);
		}
		
		/**
		 * 计算从一个墙面向外偏移指定距离后的线段位置（全局坐标位置）
		 * @param cw：指定的墙面
		 * @param offset：偏移距离
		 * @param head：偏移后的坐标
		 * @param end：偏移后的坐标
		 * @param h
		 * @param e
		 * 
		 */
		private function offsetCrossWall(cw:CrossWall,offset:int,head:Point,end:Point,h:Point3D,e:Point3D):void
		{
			//var h:Point3D = cw.localHead;
			head.x = h.x;
			head.y = h.z>0?h.z+offset:h.z-offset;
			cw.wall.localToGlobal2(head,head);
			
			//var e:Point3D = cw.localEnd;
			end.x = e.x;
			end.y = e.z>0?e.z+offset:e.z-offset;
			cw.wall.localToGlobal2(end,end);
		}
		
		/*private function offsetCrossWall(cw:CrossWall,offset:int,head:Point,end:Point):void
		{
			var h:Point3D = cw.localHead;
			head.x = h.x;
			head.y = h.z>0?h.z+offset:h.z-offset;
			cw.wall.localToGlobal2(head,head);
			
			var e:Point3D = cw.localEnd;
			end.x = e.x;
			end.y = e.z>0?e.z+offset:e.z-offset;
			cw.wall.localToGlobal2(end,end);
		}*/
		
		//布置厨柜
		//mode:center[厨柜整体居中],head[厨柜紧靠头部],end[厨柜紧靠尾部],offset[指定偏移量]
		//type:ground[地柜],wall[吊柜]
		/*private function assignCabinet(cw:CrossWall,list:Array,start:Number,end:Number,type:String,mode:String,offset:int=0):void
		{
			var space:Number = list.pop();
			if(mode=="center")
			{
				start += space*0.5;
			}
			else if(mode=="end")
			{
				start += space;
			}
			else if(mode=="offset")
			{
				start += offset;
			}
			
			var len:int = list.length;
			for(var i:int=0;i<len;i++)
			{
				var w:int = list[i];
				start += w;
				createCabinetByWidth(cw,type,w,start);
			}
		}*/
		
		//创建指定宽度的厨柜
		/*private function createCabinetByWidth(cw:CrossWall,type:String,width:int,x:Number):void
		{
			var cabinets:Array = (type=="ground")?groundCabinets:wallCabinets;
			var dict:Dictionary = (type=="ground")?groundWidthDict:wallWidthDict;
			var index:int = dict[width];//获取特定宽度厨柜的数据索引
			var o:Object = this.getCabinetData(cabinets,index);//取出厨柜数据
			if(type=="ground")
			{
				this.createGroundCabinet(o,cw,x);//创建地柜
			}
			else
			{
				this.createWallCabinet(o,cw,x);//创建吊柜
			}
		}*/
		
		//添加转角柜
		/*private function addCornerCabinet(cw:CrossWall,type:String,isHead:Boolean):void
		{
			var cabinets:Array = (type=="ground")?groundCabinets:wallCabinets;
			var index:int = (type=="ground")?25:9;
			var y:int = (type=="ground")?0:1540;
			var xOffset:int = (type=="ground")?100:10;
			
			var o:Object = getCabinetData(cabinets,index);
			var width:int = o.width;
			var height:int = o.height;
			var start:int  = isHead?cw.localHead.x+xOffset+width:cw.localEnd.x-xOffset;
			
			this.setTestObject(start,y,width,height);
			
			var result:Boolean = isHead?cw.testAutoAddToEnd(testObject,start):cw.testAutoAddToHead(testObject,start);
			//trace("----addCornerCabinet index:"+cw.wall.index+" result:"+result+" x:"+start+" width:"+width);
			
			if(result)
			{
				start = testObject.x;
				if(type=="ground")
				{
					createGroundCabinet(o,cw,start);
				}
				else
				{
					createWallCabinet(o,cw,start);
				}
			}
		}*/
		
		//测试墙面上是否有足够的空间来放置物体，并在testObject中返回可用的位置
		/*private function testWallObject(cw:CrossWall,width:int,start:Number,yPos:int=1540):Boolean
		{
			start += width*0.5;
			this.setTestObject(start,yPos,width,720);
			
			var result:Boolean = cw.testAutoAddToEnd(testObject,start);
			if(!result)result = cw.testAutoAddToHead(testObject,start);
			
			return result;
		}*/
		
		private function addCookerProduct(o:Object,cw:CrossWall,flag:WallObject):ProductObject
		{
			var id:int = o.id;
			var file:String = o.file;
			var width:int = o.width;
			var height:int = o.height;
			var depth:int = o.depth;
			var name:String = o.name;
			
			var oid:int = ProductObject.getNextIndex();
			
			var vo:ProductObject = productManager.addProductObject(oid,name,id,file);
			//this.createProduct(vo);\
			var x:Number = flag.x-flag.width*0.5;//定位放置产品的中心x位置
			var n:int = cw.wall.width*0.5+300;//定位放置产品的中心y位置
			var y:Number = cw.isHead?-n:n;
			var p:Point = new Point(x,y);
			cw.wall.localToGlobal2(p,p);
			
			vo.position.x = p.x;
			vo.position.y = 840;
			vo.position.z = p.y;
			
			var a:Number = 360 - cw.wall.angles;
			vo.rotation.y = vo.container3d.rotationY = cw.isHead ? a+180 : a;
			
			var wo:WallObject = new WallObject();
			wo.object = vo;
			wo.width = width;
			wo.height = height;
			wo.depth = depth;
			wo.x = x + width*0.5;
			
			vo.objectInfo = wo;
			
			return vo;
		}
		
		private var hoodProduct:Product2D;
		private var flueProduct:ProductObject;
		private var drainerProduct:ProductObject
		
		//添加水盆柜、灶台柜、拉篮柜、抽油烟机，
		/*private function addCookerHood(cw:CrossWall,drainer:Product2D,flue:Product2D,appliance:Boolean):void
		{
			if(drainer && flue)
			{
				if(drainer.vo.objectInfo.x>flue.vo.objectInfo.x)
				{
					addDrainer(cw,drainer);
					addFlue(cw,flue,appliance);
				}
				else
				{
					addFlue(cw,flue,appliance);
					addDrainer(cw,drainer);
				}
			}
			else if(flue)
			{
				addFlue(cw,flue,appliance);
			}
			else
			{
				addDrainer(cw,drainer);
			}
			
			productManager.loadProduct();
		}*/
		
		/*private function addFlue(cw:CrossWall,flue:Product2D,appliance:Boolean):void
		{
			var start:int  = flue.vo.objectInfo.x-flue.vo.objectInfo.width*0.5;
			var xPos:Number;
			
			if(testWallObject(cw,1500,start))//一个900的灶台柜，两个300的拉篮柜
			{
				xPos = testObject.x;
				flue.vo.objectInfo.x = xPos-750;
				
				var o:Object = cookerHoodData?cookerHoodData:getCabinetData(cookerProducts,1);//抽油烟机
				var hood:Product2D = createWallCabinet(o,cw,xPos-750+o.width*0.5);
				
				o = getCabinetData(groundCabinets,12);//拉篮柜
				var o2:Object = getCabinetData(groundCabinets,19);//灶台柜
				createGroundCabinet(o,cw,xPos);
				createGroundCabinet(o2,cw,xPos-300);
				createGroundCabinet(o,cw,xPos-1200);
			}
			else if(testWallObject(cw,1400,start))//一个800的灶台柜，两个300的拉篮柜
			{
				xPos = testObject.x;
				flue.vo.objectInfo.x = xPos-700;
				
				o = getCabinetData(cookerProducts,1);//抽油烟机
				hood = createWallCabinet(o,cw,xPos-700+o.width*0.5);
				
				o = getCabinetData(groundCabinets,12);//拉篮柜
				o2 = getCabinetData(groundCabinets,19);//灶台柜
				createGroundCabinet(o,cw,xPos);
				createGroundCabinet(o2,cw,xPos-300);
				createGroundCabinet(o,cw,xPos-1100);
			}
			
			if(hood)
			{
				o = flueData?flueData:getCabinetData(cookerProducts,3);
				flueProduct = addCookerProduct(o,cw,flue.vo.objectInfo);
				flueProduct.isLock = true;
				//flueProduct.container3d.visible = false;
				hood.vo.isLock = true;
			}
		}*/
		
		/*private function addDrainer(cw:CrossWall,drainer:Product2D):void
		{
			var start:int  = drainer.vo.objectInfo.x-drainer.vo.objectInfo.width*0.5;
			var xPos:Number;
			
			if(testWallObject(cw,900,start))//900的水盆柜
			{
				xPos = testObject.x;
				drainer.vo.objectInfo.x = xPos-450;
				
				var o:Object = getCabinetData(groundCabinets,17);
				var cabinet:Product2D = createGroundCabinet(o,cw,xPos);
			}
			else if(testWallObject(cw,800,start))//800的水盆柜
			{
				xPos = testObject.x;
				drainer.vo.objectInfo.x = xPos-400;
				
				o = getCabinetData(groundCabinets,16);
				cabinet = createGroundCabinet(o,cw,xPos);
			}
			
			if(cabinet)
			{
				o = drainerData?drainerData:getCabinetData(cookerProducts,2);
				drainerProduct = addCookerProduct(o,cw,drainer.vo.objectInfo);
				drainerProduct.isLock = true;
				//drainerProduct.container3d.visible = false;
			}
		}*/
		
		/**
		 * 添加新橱柜前，检测所添加区段是否可用，
		 * 如不可用，检查区段中的物体所在，并避让后，检测新区段是否可用
		 * 直到有可用区段，添加入新橱柜
		 * 
		 */
		private function createGroundCabinet(o:Object,cw:CrossWall,x:int,door:XML=null,elec:XML=null):Product2D
		{
			var id:int = o.id;
			var file:String = o.file;
			var width:int = o.width;
			//trace("------createGroundCabinet:"+width);
			var p:Product2D = cabinetCtr.createCabinet(id,file,"text",cw,x,0,file,false,width,550);
			if(door)//动态添加门
			{
				productManager.addDynamicSubProduct(p.vo,door);
			}
			
			if(elec)//动态添加电器
			{
				//trace("item:"+elec);
				var sub:XML =
					<item>
						<infoID>402</infoID>
						<objectID>0</objectID>
						<name></name>
						<name_en/>
						<file>cabinet_right_door_402_397x717x16.pdt</file>
						<dataFormat>text</dataFormat>
						<position>300,440,550</position>
						<rotation>0,0,0</rotation>
						<scale>1,1,1</scale>
						<active>false</active>
					</item>

				var s:String = elec.id;
				sub.infoID = s;
				sub.file = elec.file;
				productManager.addDynamicSubProduct(p.vo,sub);
				//trace("sub:"+sub);
			}
			return p;
		}
		
		private function createWallCabinet(o:Object,cw:CrossWall,x:int,door:XML=null):Product2D
		{
			var id:int = o.id;
			var file:String = o.file;
			var width:int = o.width;
			//var height:int = o.height;
			//this.setTestObject(0,1540,width,height);
			//trace("------createWallCabinet"+width);
			var p:Product2D = cabinetCtr.createCabinet(id,file,"text",cw,x,1540,file,false,width,330);
			if(door)
			{
				productManager.addDynamicSubProduct(p.vo,door);
			}
			return p;
		}
		
		/*private var testObject:WallObject = new WallObject();
		private function setTestObject(x:Number,y:Number,width:Number,height:Number):void
		{
			testObject.x = x;
			testObject.y = y;
			testObject.width = width;
			testObject.height = height;
		}*/
		
		/**
		 * 设置相机默认角度
		 */
		private function setCameraPanAngle(w1:Wall,w2:Wall=null):void
		{
			var house:House = House.getInstance();
			var a1:Number = (540-w1.angles)%360;
			if(w2)
			{
				var a2:Number = (540-w2.angles)%360;
				house.currPanAngle = (a1+a2)/2;
			}
			else
			{
				house.currPanAngle = a1;
			}
		}
		
		private var bigCabinets:Array = [800,900];
		private var smallCabinets:Array = [300,400,450,500];
		private var smallCabinets2:Array = [300,400,450,600];
		
		//开始自动创建厨柜
		/*private function _autoCreateCabinet2(cw:CrossWall,
											flue:Product2D=null,//灶台
											appliance:Boolean=false,//灶台下是否放置烤箱
											drainer:Product2D=null,//水盆
											headCorner:Boolean=false,//头部是否放置转角柜
											endCorner:Boolean=false,//尾部是否放置转角柜
											startOffset:int=0,//头部起始偏移
											endOffset:int=0):void//尾部起始偏移
		{
			return;
			
			var x0:Number = cw.localHead.x + startOffset;
			var x1:Number = cw.localEnd.x - endOffset;
			var x00:Number,x11:Number;
			
			var i:int;
			
			cw.initTestObject();
			if(headCorner)
			{
				addCornerCabinet(cw,"ground",true);//墙首转角地柜
				addCornerCabinet(cw,"wall",true);//墙首转角吊柜
			}
			
			if(endCorner)
			{
				addCornerCabinet(cw,"ground",false);//墙尾转角地柜
				addCornerCabinet(cw,"wall",false);//墙尾转角吊柜
			}
			
			cw.initTestObject();
			
			if(flue || drainer)
			{
				this.addCookerHood(cw,drainer,flue,appliance);
			}
			
			cw.initTestObject();
			
			var gos:Array = [];
			cw.getGroundObjectOfPos(x0,x1,gos);
			
			var len:int = gos.length;
			
			//trace("groundObjectsNum:"+len);//13906011621
			
			if(len==0)
			{
				var a:Array = TestNumer.matchGroupSize(x1 - x0,bigCabinets,smallCabinets);
				assignCabinet(cw,a,x0,x1,"ground","center");
			}
			else
			{
				var wo:WallObject = gos[0];
				//trace("wo x:"+wo.x+" width:"+wo.width);
				var wo2:WallObject = gos[len-1];
				//trace("wo2 x:"+wo2.x+" width:"+wo2.width);
				var mode:String,mode0:String,mode1:String;
				
				if(wo.x-wo.width-x0>300)
				{
					//trace("wo.object:"+wo.object);
					//trace("wo2.object:"+wo2.object);
					//trace("wo==wo2:"+(wo==wo2));
					
					if(wo.object is WallHole)//障碍物是墙洞时，要远离墙洞wo==wo2 && 
					{
						mode0 = "head";
					}
					else//否则，贴紧障碍物
					{
						mode0 = "end";
					}
					x11 = wo.x - wo.width;
					a = TestNumer.matchGroupSize(x11-x0,bigCabinets,smallCabinets);
					assignCabinet(cw,a,x0,x11,"ground",mode0);
				}
				
				if(x1-wo2.x>300)
				{
					if(wo2.object is WallHole)//障碍物是墙洞时，要远离墙洞wo==wo2 && 
					{
						mode1 = "end";
					}
					else//否则，贴紧障碍物
					{
						mode1 = "head";
					}
					x00 = wo2.x;
					a = TestNumer.matchGroupSize(x1-x00,bigCabinets,smallCabinets);
					assignCabinet(cw,a,x00,x1,"ground",mode1);
				}
				//trace("mode0:"+mode0);
				//trace("mode1:"+mode1);
				
				for(i=1;i<len;i++)
				{
					wo = gos[i-1];
					wo2 = gos[i];
					
					if(len==2)//只有两个障碍物时
					{
						if(mode0=="end")mode = "head";//贴紧前方障碍物
						else if(mode1=="head")mode = "end";//贴紧后方障碍物
						else
							mode = "center";
					}
					else if(wo.object is WallHole && wo2.object is WallHole)//前后障碍物都是墙洞时，厨柜在两个墙洞之间居中放置
					{
						mode = "center";
					}
					else if(wo.object is WallHole && !(wo2.object is WallHole))//前面是墙洞，后面不是墙洞时，厨柜贴紧后面的障碍物放置
					{
						mode = "end";
					}
					else if(!(wo.object is WallHole) && wo2.object is WallHole)//前面不是墙洞，后面是墙洞时，厨柜贴紧前面的障碍物放置
					{
						mode = "head";
					}
					else//前后都不是墙洞
					{
						if(i==1 && !mode0)//障碍物之前没有物品，贴紧后方障碍物
						{
							mode = "end";
						}
						else if(i==len-1 && !mode1)//障碍物之后没有物品，贴紧前方障碍物
						{
							mode = "head";
						}
						else//其它情况，厨柜居中
						{
							mode = "center";
						}
					}
					//trace(i+" mode:"+mode);
					
					if(wo2.x-wo2.width-wo.x>300)
					{
						x00 = wo.x;
						x11 = wo2.x - wo2.width;
						a = TestNumer.matchGroupSize(x11-x00,bigCabinets,smallCabinets);
						assignCabinet(cw,a,x00,x11,"ground",mode);
					}
				}
			}
			
			if(startOffset>0)x0 = cw.localHead.x + 350;
			if(endOffset>0)x1 = cw.localEnd.x - 350;
			
			var wos:Array = [];
			cw.getWallObjectOfPos(x0,x1,wos);
			
			len = wos.length;
			
			//trace("wallObjectsNum:"+len);
			
			if(len==0)
			{
				a = TestNumer.matchGroupSize(x1 - x0,bigCabinets,smallCabinets2);
				assignCabinet(cw,a,x0,x1,"wall","center");
			}
			else
			{
				wo = wos[0];
				wo2 = wos[len-1];
				
				if(wo.x-wo.width-x0>300)
				{
					if(wo==wo2 && wo.object is WallHole)//障碍物是墙洞时，要远离墙洞
					{
						mode0 = "head";
					}
					else//否则，贴紧障碍物
					{
						mode0 = "end";
					}
					x11 = wo.x - wo.width;
					a = TestNumer.matchGroupSize(x11-x0,bigCabinets,smallCabinets2);
					assignCabinet(cw,a,x0,x11,"wall",mode0);
				}
				else
				{
					mode0 = null;
				}
				
				if(x1-wo2.x>300)
				{
					if(wo==wo2 && wo.object is WallHole)//障碍物是墙洞时，要远离墙洞
					{
						mode1 = "end";
					}
					else//否则，贴紧障碍物
					{
						mode1 = "head";
					}
					x00 = wo2.x;
					a = TestNumer.matchGroupSize(x1-x00,bigCabinets,smallCabinets2);
					assignCabinet(cw,a,x00,x1,"wall",mode1);
				}
				else
				{
					mode1 = null;
				}
				
				for(i=1;i<len;i++)
				{
					wo = wos[i-1];
					wo2 = wos[i];
					
					if(len==2)//只有两个障碍物时
					{
						if(mode0=="end")mode = "head";//贴紧前方障碍物
						else if(mode1=="head")mode = "end";//贴紧后方障碍物
						else
							mode = "center";
					}
					else if(wo.object is WallHole && wo2.object is WallHole)//前后障碍物都是墙洞时，厨柜在两个墙洞之间居中放置
					{
						mode = "center";
					}
					else if(wo.object is WallHole && !(wo2.object is WallHole))//前面是墙洞，后面不是墙洞时，厨柜贴紧后面的障碍物放置
					{
						mode = "end";
					}
					else if(!(wo.object is WallHole) && wo2.object is WallHole)//前面不是墙洞，后面是墙洞时，厨柜贴紧前面的障碍物放置
					{
						mode = "head";
					}
					else//前后都不是墙洞
					{
						if(i==1 && !mode0)//障碍物之前没有物品，贴紧后方障碍物
						{
							mode = "end";
						}
						else if(i==len-1 && !mode1)//障碍物之后没有物品，贴紧前方障碍物
						{
							mode = "head";
						}
						else//其它情况，厨柜居中
						{
							mode = "center";
						}
					}
					
					if(wo2.x-wo2.width-wo.x>300)
					{
						x00 = wo.x;
						x11 = wo2.x - wo2.width;
						a = TestNumer.matchGroupSize(x11-x00,bigCabinets,smallCabinets2);
						assignCabinet(cw,a,x00,x11,"wall",mode);
					}
				}
			}
			
			cw.initTestObject();
			cw.wall.isChanged = true;
			
			cabinetCtr.scene.render();
		}*/
		
		private function getCabinetData(cabinets:Array,index:int=-1):Object
		{
			index = (index<0 || index>cabinets.length-1) ? int(Math.random()*cabinets.length) : index;
			var o:Object = cabinets[index];
			//var h:int = o.height;
			//if(h>720)o=getCabinetData();
			return o;
		}
		
		//场景中的地柜（包括封板）
		private var sceneGroundCabinets:Array = [];
		//场景中的吊柜（包括封板）
		private var sceneWallCabinets:Array = [];
		
		private var groundCabinets:Array;
		
		private var wallCabinets:Array;
		
		private var cookerProducts:Array;
		
		private var groundWidthDict:Dictionary = new Dictionary();
		
		private var wallWidthDict:Dictionary = new Dictionary();
		
		private function initCabinetData():void
		{
			groundCabinets = [
				{id:"501",file:"cabinet_501_300x720x570.pdt" ,width:"300",height:"720" ,name:"单门地柜"},//0
				{id:"502",file:"cabinet_502_400x720x570.pdt" ,width:"400",height:"720" ,name:"单门地柜"},//1
				{id:"503",file:"cabinet_503_450x720x570.pdt" ,width:"450",height:"720" ,name:"单门地柜"},//2
				{id:"504",file:"cabinet_504_500x720x570.pdt" ,width:"500",height:"720" ,name:"单门地柜"},//3
				{id:"506",file:"cabinet_506_800x720x570.pdt" ,width:"800",height:"720" ,name:"双门地柜"},//4
				{id:"507",file:"cabinet_507_900x720x570.pdt" ,width:"900",height:"720" ,name:"双门地柜"},//5
				{id:"513",file:"cabinet_513_450x720x570.pdt" ,width:"450",height:"720" ,name:"小小大抽屉柜"},//6
				{id:"515",file:"cabinet_515_600x720x570.pdt" ,width:"600",height:"720" ,name:"小小大抽屉柜"},//7
				{id:"546",file:"cabinet_546_800x720x570.pdt" ,width:"800",height:"720" ,name:"二平分抽屉地柜"},//8
				{id:"547",file:"cabinet_547_900x720x570.pdt" ,width:"900",height:"720" ,name:"二平分抽屉地柜"},//9
				{id:"525",file:"cabinet_525_600x720x570.pdt" ,width:"600",height:"720" ,name:"消毒柜"},//10
				{id:"510",file:"cabinet_510_200x720x570.pdt" ,width:"200",height:"720" ,name:"调味拉篮柜"},//11
				{id:"511",file:"cabinet_511_300x720x570.pdt" ,width:"300",height:"720" ,name:"调味拉篮柜"},//12
				{id:"512",file:"cabinet_512_400x720x570.pdt" ,width:"400",height:"720" ,name:"调味拉篮柜"},//13
				{id:"536",file:"cabinet_536_800x720x570.pdt" ,width:"800",height:"720" ,name:"二平分拉篮柜"},//14
				{id:"537",file:"cabinet_537_900x720x570.pdt" ,width:"900",height:"720" ,name:"二平分拉篮柜"},//15
				{id:"516",file:"cabinet_516_800x720x570.pdt" ,width:"800",height:"720" ,name:"双门水槽柜"},//16
				{id:"517",file:"cabinet_517_900x720x570.pdt" ,width:"900",height:"720" ,name:"双门水槽柜"},//17
				{id:"526",file:"cabinet_526_800x720x570.pdt" ,width:"800",height:"720" ,name:"双门炉台柜"},//18
				{id:"527",file:"cabinet_527_900x720x570.pdt" ,width:"900",height:"720" ,name:"双门炉台柜"},//19
				{id:"703",file:"cabinet_703_450x1390x570.pdt",width:"450",height:"1390",name:"单木门中高柜"},//20
				{id:"705",file:"cabinet_705_600x1390x570.pdt",width:"600",height:"1390",name:"单木门中高柜"},//21
				{id:"805",file:"cabinet_805_600x2110x570.pdt",width:"600",height:"2110",name:"门+门高柜"},//22
				{id:"715",file:"cabinet_715_600x1390x570.pdt",width:"600",height:"1390",name:"烤箱、微波炉功能柜"},//23
				{id:"815",file:"cabinet_815_600x2110x570.pdt",width:"600",height:"2110",name:"烤箱、微波炉功能柜"},//24
				{id:"557",file:"cabinet_557_900x720x570.pdt" ,width:"900",height:"720" ,name:"单门转角地柜"}//25
			];
			
			groundWidthDict[300] = 0;
			groundWidthDict[400] = 1;
			groundWidthDict[450] = 2;
			groundWidthDict[500] = 3;
			groundWidthDict[600] = 10;
			groundWidthDict[800] = 4;
			groundWidthDict[900] = 5;
			
			wallCabinets = [
				{id:"601",file:"cabinet_601_300x720x330.pdt",width:"300",height:"720",name:"单门吊柜"},//0
				{id:"602",file:"cabinet_602_400x720x330.pdt",width:"400",height:"720",name:"单门吊柜"},//1
				{id:"603",file:"cabinet_603_450x720x330.pdt",width:"450",height:"720",name:"单门吊柜"},//2
				{id:"605",file:"cabinet_605_600x720x330.pdt",width:"600",height:"720",name:"单门吊柜"},//3
				{id:"606",file:"cabinet_606_800x720x330.pdt",width:"800",height:"720",name:"双门吊柜"},//4
				{id:"607",file:"cabinet_607_900x720x330.pdt",width:"900",height:"720",name:"双门吊柜"},//5
				{id:"616",file:"cabinet_616_800x720x330.pdt",width:"800",height:"720",name:"双上翻门吊柜"},//6
				{id:"617",file:"cabinet_617_900x720x330.pdt",width:"900",height:"720",name:"双上翻门吊柜"},//7
				{id:"615",file:"cabinet_615_600x720x330.pdt",width:"600",height:"720",name:"微波炉吊柜"},//8
				{id:"626",file:"cabinet_626_800x720x330.pdt",width:"800",height:"720",name:"单门转角吊柜"}//9
				//{id:"1101",file:"cooker_hood_1101.pdt",width:"800",height:"700",name:"抽油烟机"},//10
				//{id:"1102",file:"cooker_hood_1102_CXW-268-L1.pdt",width:"896",height:"860",name:"抽油烟机"}//11
			];
			
			wallWidthDict[300] = 0;
			wallWidthDict[400] = 1;
			wallWidthDict[450] = 2;
			wallWidthDict[600] = 3;
			wallWidthDict[800] = 4;
			wallWidthDict[900] = 5;
			
			cookerProducts = [
				{id:"1101",file:"cooker_hood_1101.pdt",width:"800",height:"700",name:"抽油烟机"},//0
				{id:"1102",file:"cooker_hood_1102_CXW-268-P.pdt",width:"896",height:"860",name:"抽油烟机"},//1
				{id:"1201",file:"drainer_1201_SC8146.pdt",width:"752",height:"497",depth:"437",name:"水盆"},//2
				{id:"1301",file:"flue_1301_GP1310Z1.pdt",width:"713",height:"50",depth:"435",name:"灶台"},//3
				{id:"1305",file:"flue_1305_GP090.pdt",width:"778",height:"49",depth:"445",name:"灶台"}//4
			];
		}
		
		//==============================================================================================
		public function CabinetCreator2(value:InstanceClass)
		{
			if(!value)
			{
				throw new Error("WallController是一个单例类，请用静态方法getInstance来获得类的实例。");
			}
			
			initCabinetData();
		}
		
		//==============================================================================================
		static private var instance:CabinetCreator2;
		private var lastTime:int;
		
		static public function getInstance():CabinetCreator2
		{
			instance ||= new CabinetCreator2(new InstanceClass());
			return instance;
		}
		
		//==============================================================================================
	}
}

class InstanceClass{}

